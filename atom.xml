<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GAJYA的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gajya.github.io/"/>
  <updated>2020-01-16T03:13:59.701Z</updated>
  <id>http://gajya.github.io/</id>
  
  <author>
    <name>GAJYA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sass文档</title>
    <link href="http://gajya.github.io/2020/01/16/Sass%E6%96%87%E6%A1%A3/"/>
    <id>http://gajya.github.io/2020/01/16/Sass文档/</id>
    <published>2020-01-16T03:07:46.000Z</published>
    <updated>2020-01-16T03:13:59.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sass文档"><a href="#Sass文档" class="headerlink" title="Sass文档"></a>Sass文档</h2><blockquote><p>Sass是一种css的预编译语言。提供了变量（variables）、嵌套（nestedrules）、混合（mixins）、函数（functions）等功能，并且完全兼容css语法。</p></blockquote><p>它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的css文件。</p><a id="more"></a><h2 id="Sass用法指南"><a href="#Sass用法指南" class="headerlink" title="Sass用法指南"></a>Sass用法指南</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h4><p>sass允许使用变量，所有变量以<code>$</code>开头。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$-primary-color</span>: <span class="number">#16b3fc</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$-primary-color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果变量需要嵌入在字符串之间，必须要写在<code>#{}</code>之中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$side</span>: left;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>-#&#123;<span class="variable">$side</span>&#125;: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-计算功能"><a href="#2-计算功能" class="headerlink" title="2.  计算功能"></a>2.  计算功能</h4><p>   sass允许在代码中使用算式：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$var</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: (<span class="number">20px</span>/<span class="number">2</span>);</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span> + <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="variable">$var</span> * <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-嵌套"><a href="#3-嵌套" class="headerlink" title="3. 嵌套"></a>3. 嵌套</h4><p>   sass允许选择器嵌套，属性也可以嵌套，比如<code>border-color</code>属性，可以写成</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，border后面必须加上冒号</span></span><br><span class="line"><span class="selector-tag">button</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:&#123;</span><br><span class="line">        color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   在嵌套的代码块内，使用<code>&amp;</code>引用父元素，例如<code>button:hover</code>，可以写成：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    &amp;:hover&#123;</span><br><span class="line">        <span class="attribute">border</span>:&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h4><p>   sass两种注释方式</p><ul><li>标准的<code>/* comment*/</code>，会保留到编译后的文件</li><li>单行注释<code>// comment</code>，编译后会被省略</li><li>重要注释<code>/*! comment*/</code>，即使是压缩模式编译，也会保留这行注释，通常用于声明版权。</li></ul><h3 id="代码的复用"><a href="#代码的复用" class="headerlink" title="代码的复用"></a>代码的复用</h3><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><p>   sass还允许一个选择器继承另一个选择器，例如：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <code>button2</code>要继承<code>button1</code>，可以使用<code>@extend</code>命令：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button2</span>&#123;</span><br><span class="line">    @<span class="keyword">extend</span> .button1;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-mixin混入"><a href="#2-mixin混入" class="headerlink" title="2. mixin混入"></a>2. mixin混入</h4><p>   mixin是可以复用的代码块。</p><p>   使用<code>@mixin</code>命令，定义一个代码块。</p><p>   可以直接写死某些内容，直接使用，也<strong>可以指定参数和缺省值</strong>，例：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> base-color-style(<span class="variable">$--background-color</span>,<span class="variable">$--color</span>,<span class="variable">$--border-color</span>: blue)&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$--background-color</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$--color</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="variable">$--border-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   使用<code>@include</code>命令，调用这个mixin。</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span>&#123;</span><br><span class="line">    @<span class="keyword">include</span> base-color-style(blue, white, skyblue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-颜色函数"><a href="#3-颜色函数" class="headerlink" title="3. 颜色函数"></a>3. 颜色函数</h4><p>   sass提供了一些内置的颜色函数，方便生成系列颜色。</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lighten(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #d6d65c</span></span><br><span class="line">darken(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #a3a329</span></span><br><span class="line">grayscale(<span class="selector-id">#cc3</span>) <span class="comment">// #808080</span></span><br><span class="line">complement(<span class="selector-id">#cc3</span>) <span class="comment">// #33c</span></span><br></pre></td></tr></table></figure><h4 id="4-插入文件"><a href="#4-插入文件" class="headerlink" title="4. 插入文件"></a>4. 插入文件</h4><p>   <code>@import</code>命令，来插入外部文件。如果是插入的<code>.css</code>文件，等同于css的import命令</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'./common/var.scss'</span></span><br></pre></td></tr></table></figure><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1. 条件语句"></a>1. 条件语句</h4><p>   <code>@if</code>用来判断：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span>&#123;</span><br><span class="line">    @<span class="keyword">if</span> 1 + 1 = 2 &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid;&#125;</span><br><span class="line">    @<span class="keyword">if</span> 5 &lt; 3 &#123; <span class="attribute">border</span>: <span class="number">2px</span> dotted; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <code>@else</code>命令：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">if</span> lightness(<span class="variable">$color</span>) &gt; 30% &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h4><p>   sass支持for循环：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 10 &#123;</span><br><span class="line">　　<span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">　　　　<span class="attribute">border</span>: #&#123;<span class="variable">$i</span>&#125;px solid blue;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   while循环：</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">while</span> <span class="variable">$i</span> &gt; 0 &#123;</span><br><span class="line">    <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <code>@each</code>命令，作用和@for类似，和<code>@for</code>的差别在于，<code>@each</code>通过遍历 <code>list</code>或者 <code>map</code>实现循环输出:</p><ul><li><p>list：指列表</p></li><li><p>map：可以包含若干值的对象类型，使用<code>()</code>包裹一个map，里面的键值用逗号隔开，键和值可以是任何的sass数据类型，键必须唯一。</p><p>注意：map不能直接在css中使用，把map赋值给一个元素会报错。</p><p>list例子：</p> <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$var</span> in &lt;list&gt;</span><br><span class="line">/*</span><br><span class="line">  var是变量名，list是一个sassScript表达式，它会返回一个列表值。   </span><br><span class="line"> */</span><br><span class="line"><span class="variable">$list</span>: aa,bb,cc,dd,ee; <span class="comment">// 多个变量，可以用空格，也可以使用逗号隔开</span></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$member</span> in <span class="variable">$list</span> &#123;</span><br><span class="line">  　　　　.#&#123;<span class="variable">$member</span>&#125; &#123;</span><br><span class="line">  　　　　　　<span class="attribute">background-image</span>: url(<span class="string">"/image/#&#123;$member&#125;.jpg"</span>);</span><br><span class="line">  　　　　&#125;</span><br><span class="line">  　　&#125;</span><br></pre></td></tr></table></figure></li></ul><p>多个列表的遍历，我们也可以使用多个参数来保存相应的元素，例子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$alt</span>: alert, yellow, red;</span><br><span class="line"></span><br><span class="line"><span class="variable">$sub</span>: submit, white, green;</span><br><span class="line"></span><br><span class="line"><span class="variable">$bck</span>: back, blue, transparent;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$type</span>, <span class="variable">$txt</span>, <span class="variable">$back</span> in <span class="variable">$alt</span>,<span class="variable">$sub</span>,<span class="variable">$bck</span> &#123;</span><br><span class="line">  .#&#123;<span class="variable">$type</span>&#125;-<span class="selector-tag">button</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="variable">$txt</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: <span class="variable">$back</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map，我们就可以使用<code>两个变量</code>来存储元素的 <code>key</code> 和<code>value</code>例子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$params</span>: (a1: a, a2:b, a3: c);</span><br><span class="line"></span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$key</span>, <span class="variable">$a</span> in <span class="variable">$params</span> &#123;</span><br><span class="line">    .#&#123;<span class="variable">$member</span>&#125; &#123;</span><br><span class="line">　　　　　　<span class="attribute">background-image</span>: url(<span class="string">"/image/#&#123;$a&#125;.jpg"</span>);</span><br><span class="line">　　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-自定义函数"><a href="#3-自定义函数" class="headerlink" title="3. 自定义函数"></a>3. 自定义函数</h4><p>   sass允许用户编写自己的函数</p>   <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function double(<span class="variable">$n</span>) &#123;</span><br><span class="line">    @return <span class="variable">$n</span> * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: double(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Sass文档&quot;&gt;&lt;a href=&quot;#Sass文档&quot; class=&quot;headerlink&quot; title=&quot;Sass文档&quot;&gt;&lt;/a&gt;Sass文档&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Sass是一种css的预编译语言。提供了变量（variables）、嵌套（nestedrules）、混合（mixins）、函数（functions）等功能，并且完全兼容css语法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的css文件。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/css/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="scss" scheme="http://gajya.github.io/tags/scss/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句</title>
    <link href="http://gajya.github.io/2019/12/05/SQL%E8%AF%AD%E5%8F%A5/"/>
    <id>http://gajya.github.io/2019/12/05/SQL语句/</id>
    <published>2019-12-05T08:57:45.498Z</published>
    <updated>2019-12-06T01:39:09.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><h3 id="一、运行MySQL"><a href="#一、运行MySQL" class="headerlink" title="一、运行MySQL"></a>一、运行MySQL</h3><p>命令提示符下输入<code>mysql -u root -p</code>，然后输入口令，如果一切正确，会连接到MySQL服务器，同时提示符变为<code>mysql</code>。</p><p>输入<code>exit</code>退出MySQL命令行。注意，MySQL服务器仍在后台运行。</p><a id="more"></a><h3 id="二、关系模型"><a href="#二、关系模型" class="headerlink" title="二、关系模型"></a>二、关系模型</h3><p><code>主键</code>是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p><p>关系数据库通过<code>外键</code>可以实现一对多、多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅依靠应用程序的逻辑来保证。</p><p><strong>添加外键</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id   </span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br><span class="line">// 外键约束的名称为fk_class_id(名称可以任意)；指定class_id作为外键，classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）</span><br></pre></td></tr></table></figure><p><strong>删除外键约束</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><h3 id="三、查询数据"><a href="#三、查询数据" class="headerlink" title="三、查询数据"></a>三、查询数据</h3><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><p>要查询数据库表的数据，我们使用如下的SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt;</span><br></pre></td></tr></table></figure><p><code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</span><br></pre></td></tr></table></figure><p>条件表达式可以用：（字符串，需要用单引号括起来）</p><ol><li><p><code>&lt;条件1&gt; AND &lt;条件2&gt;</code>，表示满足条件1并且满足条件2</p></li><li><p><code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，表示满足条件1或者满足条件2</p></li><li><p><code>NOT &lt;条件&gt;</code>，表示“不符合该条件”的记录</p></li></ol><p>组合三个或者更多的条件，就需要用小括号<code>()</code>表示如何进行条件运算</p><p><strong>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。加上括号可以改变优先级。</strong></p><table><thead><tr><th style="text-align:left">条件</th><th style="text-align:left">表达式举例1</th><th style="text-align:left">表达式举例2</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">使用&lt;&gt;判断不相等</td><td style="text-align:left">score &lt;&gt; 80</td><td style="text-align:left">name &lt;&gt; ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用LIKE判断相似</td><td style="text-align:left">name LIKE ‘ab%’</td><td style="text-align:left">name LIKE ‘%bc%’</td><td style="text-align:left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr></tbody></table><h4 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h4><p>使用<code>SELECT *</code>表示查询表的所有列，使用<code>SELECT 列1, 列2, 列3</code>则可以仅返回指定列，这种操作称为投影。</p><p><code>SELECT</code>语句可以对结果集的列进行重命名。</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score points, name FROM students;</span><br><span class="line">-- score列重命名为points</span><br></pre></td></tr></table></figure><h3 id="四、-修改数据"><a href="#四、-修改数据" class="headerlink" title="四、 修改数据"></a>四、 修改数据</h3><p><strong>INSERT</strong></p><p><code>INSERT</code>语句的基本语法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM &lt;表名&gt;;</span><br></pre></td></tr></table></figure><p>注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。</p><p><strong>UPDATE</strong></p><p><code>UPDATE</code>语句的基本语法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 更新id=1的记录</span><br><span class="line">UPDATE students SET name=&apos;大牛&apos;, score=66  WHERE id=1;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><ol><li>更新字段时可以使用表达式</li><li>如果<code>WHERE</code>条件没有匹配到任何记录，<code>UPDATE</code>语句不会报错，也不会有任何记录被更新</li><li><code>UPDATE</code>语句可以没有<code>WHERE</code>条件</li></ol><p><strong>DELETE</strong></p><p><code>DELETE</code>语句的基本语法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; WHERE ...;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=5,6,7的记录</span><br><span class="line">DELETE FROM students WHERE id&gt;=5 AND id&lt;=7;</span><br><span class="line">-- 查询并观察结果:</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><p><strong><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1246617682185952" target="_blank" rel="noopener">实用SQL语句</a></strong></p><p><strong><a href="http://www.mysqltutorial.org/mysql-select-statement-query-data.aspx" target="_blank" rel="noopener">MySQL SELECT</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SQL语句&quot;&gt;&lt;a href=&quot;#SQL语句&quot; class=&quot;headerlink&quot; title=&quot;SQL语句&quot;&gt;&lt;/a&gt;SQL语句&lt;/h2&gt;&lt;h3 id=&quot;一、运行MySQL&quot;&gt;&lt;a href=&quot;#一、运行MySQL&quot; class=&quot;headerlink&quot; title=&quot;一、运行MySQL&quot;&gt;&lt;/a&gt;一、运行MySQL&lt;/h3&gt;&lt;p&gt;命令提示符下输入&lt;code&gt;mysql -u root -p&lt;/code&gt;，然后输入口令，如果一切正确，会连接到MySQL服务器，同时提示符变为&lt;code&gt;mysql&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;exit&lt;/code&gt;退出MySQL命令行。注意，MySQL服务器仍在后台运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://gajya.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>WebStorm相关</title>
    <link href="http://gajya.github.io/2019/12/02/WebStorm%E7%95%8C%E9%9D%A2%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%EF%BC%88%E5%87%BA%E7%8E%B0%E5%8F%A3%E5%8F%A3%E5%8F%A3%EF%BC%89/"/>
    <id>http://gajya.github.io/2019/12/02/WebStorm界面出现中文乱码（出现口口口）/</id>
    <published>2019-12-02T07:07:55.403Z</published>
    <updated>2019-12-02T07:13:58.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="WebStorm界面出现中文乱码（出现口口口）"><a href="#WebStorm界面出现中文乱码（出现口口口）" class="headerlink" title="WebStorm界面出现中文乱码（出现口口口）"></a>WebStorm界面出现中文乱码（出现口口口）</h3><p>新下载的webstorm2.1，搜索文件的时候，搜索框内输入中文，展示为口口口，解决这个问题方法：</p><ol><li>点击settings，快捷键Ctrl+Alt+S</li><li>点击Appearance选项</li><li>勾选【Use custom font】，随便选个其他的字体，看一下，一般就可以了</li><li>点击【ok】</li></ol><h3 id="webstorms使用svn提交代码"><a href="#webstorms使用svn提交代码" class="headerlink" title="webstorms使用svn提交代码"></a>webstorms使用svn提交代码</h3><p>提交代码时候一直显示refreshing VCS，时间很久很久<br>换个版本吧，少年。。。<br>尝试了一些网上的解决方法，都没办法永久解决（webstorm3遇到的这个问题）<br>现已把版本换回2.1，谢谢这个版本拯救了我<br>(￣▽￣)~*</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;WebStorm界面出现中文乱码（出现口口口）&quot;&gt;&lt;a href=&quot;#WebStorm界面出现中文乱码（出现口口口）&quot; class=&quot;headerlink&quot; title=&quot;WebStorm界面出现中文乱码（出现口口口）&quot;&gt;&lt;/a&gt;WebStorm界面出现中文乱码（
      
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Chrome浏览器performance工具</title>
    <link href="http://gajya.github.io/2019/11/12/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8performance%E5%B7%A5%E5%85%B7/"/>
    <id>http://gajya.github.io/2019/11/12/Chrome浏览器performance工具/</id>
    <published>2019-11-12T06:27:09.929Z</published>
    <updated>2019-12-02T07:23:31.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chrome浏览器performance工具"><a href="#Chrome浏览器performance工具" class="headerlink" title="Chrome浏览器performance工具"></a>Chrome浏览器performance工具</h2><p> 摁 <code>Control+shift+I</code> 打开开发者工具就可以找到 <code>performance</code> (旧版本也叫<code>Timeline</code>) </p> <a id="more"></a><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul><li>点击面板左上方圆形按钮开始记录，然后操作页面，一段时间之后在面板上点击停止，即可得到这段操作过程的记录结果。</li><li>点击面板上左上方刷新按键，可以重新加载页面并获得该过程记录结果。</li><li><p>点击面板左上方禁止符号，可以清除记录结果。</p><p><code>Network</code> 和 <code>CPU</code> 两个下拉框选项的作用是模拟移动端运行环境。 </p></li></ul><p>缩略图中一共分为5行，从上到下依次是：</p><ol><li>FPS，表示每一秒的帧数，用来衡量页面动画的性能指标。fps图中绿色柱状越高表示体验越好。若出现红色长条则表示在该时间端出现长帧，可能影响用户体验。</li><li>CPU，表示cpu的使用情况，其中颜色含义和底下的<code>Summary</code>模块中相同。从该行中颜色块的跨越时长可以分析哪类事件消耗的时间较长，从而找到性能瓶颈。</li><li>NET，每一个颜色条表示加载一种文件。蓝色表示html文件、黄色表示js文件、紫色表示样式文件、绿色表示媒体文件、灰色表示其他资源。</li><li>缩略图，对应每一时刻页面的显示情况。通过勾选上方 <code>Screenshots</code> 来控制显示或隐藏。</li><li><p>HEAP，表示堆内存使用情况。可通过勾选上访 <code>Menory</code> 来控制显示或隐藏。</p><h3 id="详情图版块和Summary面板"><a href="#详情图版块和Summary面板" class="headerlink" title="详情图版块和Summary面板"></a>详情图版块和Summary面板</h3><p><a href="https://juejin.im/post/5a5ec3a8518825545d75ccef" target="_blank" rel="noopener">使用chrome performance 查看页面性能</a></p></li></ol><blockquote><p> 蓝色(Loading)：网络通信和HTML解析<br>黄色(Scripting)：JavaScript执行<br>紫色(Rendering)：样式计算和布局，即重排<br>绿色(Painting)：重绘<br>灰色(other)：其它事件花费的时间<br>白色(Idle)：空闲时间 </p></blockquote><ul><li>summary:统计报表</li><li>Bottom-Up:事件时长顺序</li><li>Call Tree:事件调用顺序</li><li>Event log:事件发生的先后顺序</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了如何通过Performance查看CPU、FPS以及对应的耗时操作，知道这些后就可以定向去优化了。</p><ol><li><p>FPS部分，如果红线比较多则代表CPU压力比较大，界面卡顿，如果绿线比较多则代表界面流畅，不卡顿</p></li><li><p>CPU部分，如果黄色区域高且持续出现，代表该处CPU压力较大，如果黄色区域不高，则代表CPU正常运行，页面整体性能很好。</p></li><li><p>Frames部分，代表在执行一次requestAnimationFrame时页面的帧率以及每帧执行时间。</p></li><li><p>Main部分，x轴代表随着时间推移的记录，y轴代表调用栈（执行事件），x轴事件越长执行时间越长，代表该处函数有优化空间，如果执行时间特别长浏览器会强势回流，查看y轴可以看到具体函数定向去优化。点击Main中的事件查看Summary中的可以看到各个阶段（Scripting、Rendering等）执行时间，以及对应事件链接到的源代码位置。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Chrome浏览器performance工具&quot;&gt;&lt;a href=&quot;#Chrome浏览器performance工具&quot; class=&quot;headerlink&quot; title=&quot;Chrome浏览器performance工具&quot;&gt;&lt;/a&gt;Chrome浏览器performance工具&lt;/h2&gt;&lt;p&gt; 摁 &lt;code&gt;Control+shift+I&lt;/code&gt; 打开开发者工具就可以找到 &lt;code&gt;performance&lt;/code&gt; (旧版本也叫&lt;code&gt;Timeline&lt;/code&gt;) &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ESLint报错解决方案</title>
    <link href="http://gajya.github.io/2019/11/12/ESLint%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88error%20No%20ESLint%20configuration%20found%EF%BC%89/"/>
    <id>http://gajya.github.io/2019/11/12/ESLint报错解决方案（error No ESLint configuration found）/</id>
    <published>2019-11-12T02:25:37.401Z</published>
    <updated>2019-12-02T08:36:50.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ESLint报错解决方案（error-No-ESLint-configuration-found）"><a href="#ESLint报错解决方案（error-No-ESLint-configuration-found）" class="headerlink" title="ESLint报错解决方案（error: No ESLint configuration found）"></a>ESLint报错解决方案（error: No ESLint configuration found）</h2><p> 在项目部署中出现报错error: No ESLint configuration found，编辑器vscode。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>造成这种报错的原因是项目中缺少 .eslintrc.js文件。添加上就可以了。</p> <a id="more"></a><h3 id="添加文件方法"><a href="#添加文件方法" class="headerlink" title="添加文件方法"></a>添加文件方法</h3><ol><li>手动添加， 直接手动添加.eslintrc.js文件在项目中，并进行相应的配置就行了。 </li><li>使用命令添加， 如果eslint是全局安装的话，使用命令eslint –init安装。 </li></ol><h3 id="配置信息（简单版）"><a href="#配置信息（简单版）" class="headerlink" title="配置信息（简单版）"></a>配置信息（简单版）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  env: &#123;</span><br><span class="line">    node: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'extends'</span>: [</span><br><span class="line">    <span class="string">'plugin:vue/essential'</span>,</span><br><span class="line">    <span class="string">'@vue/standard'</span></span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">      <span class="comment">// 生产环境不能使用console</span></span><br><span class="line">    <span class="string">'no-console'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'error'</span> : <span class="string">'off'</span>,</span><br><span class="line">      <span class="comment">// 生产环境不能使用debugger</span></span><br><span class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'error'</span> : <span class="string">'off'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">'babel-eslint'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ul><li><code>&quot;no-undef&quot;: 0,</code>和<code>&quot;no-undef&quot;: &#39;off&#39;,</code>一样，表示关闭该功能</li><li><code>&quot;no-undef&quot;: 1,</code> 表示仅提示</li><li><code>&quot;no-undef&quot;: 2,</code> 表示报错</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ESLint报错解决方案（error-No-ESLint-configuration-found）&quot;&gt;&lt;a href=&quot;#ESLint报错解决方案（error-No-ESLint-configuration-found）&quot; class=&quot;headerlink&quot; title=&quot;ESLint报错解决方案（error: No ESLint configuration found）&quot;&gt;&lt;/a&gt;ESLint报错解决方案（error: No ESLint configuration found）&lt;/h2&gt;&lt;p&gt; 在项目部署中出现报错error: No ESLint configuration found，编辑器vscode。&lt;/p&gt;
&lt;h3 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h3&gt;&lt;p&gt;造成这种报错的原因是项目中缺少 .eslintrc.js文件。添加上就可以了。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
      <category term="工具" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/tags/vue/"/>
    
      <category term="vue-工具" scheme="http://gajya.github.io/tags/vue-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vim基本使用</title>
    <link href="http://gajya.github.io/2019/10/24/vim%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://gajya.github.io/2019/10/24/vim基本使用/</id>
    <published>2019-10-24T07:23:05.416Z</published>
    <updated>2019-10-24T07:31:15.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim命令模式"><a href="#vim命令模式" class="headerlink" title="vim命令模式"></a>vim命令模式</h2><ol><li>普通模式（默认，其他模式按<code>esc</code>返回）</li><li>命令行模式（按<code>：</code>进入）</li><li>插入模式（按<code>a</code>或者<code>i</code>进入）</li></ol><p>命令行模式输入<code>wq</code>回车后保存并退出vim<br> <a id="more"></a></p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li><p>进入文件 vim fileName</p></li><li><p>进入插入模式方法</p><p>| 命令 | 说明                                     |<br>| —- | —————————————- |<br>| <code>i</code>  | 在当前光标处进行编辑                     |<br>| <code>I</code>  | 在行首插入                               |<br>| <code>A</code>  | 在行末插入                               |<br>| <code>a</code>  | 在光标后插入编辑                         |<br>| <code>o</code>  | 在当前行后插入一个新行                   |<br>| <code>O</code>  | 在当前行前插入一个新行                   |<br>| <code>cw</code> | 替换从光标所在位置后到一个单词结尾的字符 |</p></li><li><p>退出</p><ul><li>普通模式下退出vim输入shift+zz即可保存退出vim</li><li>命令行模式:wq——保存并退出</li><li>:q!强制退出</li><li>:q退出</li><li>:w &lt;文件路径&gt;             :saveas 文件路径 另存为</li><li>:x保存并退出</li></ul></li></ul><h2 id="vim文档编辑"><a href="#vim文档编辑" class="headerlink" title="vim文档编辑"></a>vim文档编辑</h2><ul><li><p>vim重复命令——</p><ul><li>普通模式下<code>.</code>表示重复上一次的命令操作</li><li>普通模式，输入<code>N&lt;command&gt;</code>，N表示重复后面的次数<ul><li><code>10x</code>——删除10个连续字符</li><li><code>3dd</code>——删除3行文本</li><li><code>.</code>——重复上一次的命令（例：重复3dd）</li><li><code>dw或者daw(delete a word)</code>——删除一个单词</li><li><code>dnw(n替换为相应数字)</code>——表示删除n个单词</li></ul></li></ul></li><li><p>跳转命令</p><ul><li><p>行间跳转</p><ul><li>:set nu——显示行号</li><li>nG（n shift+g) ——移动到第n行</li><li>gg——移动到第一行</li><li>G——到最后一行</li></ul><p><strong>小技巧</strong>：<strong>在完成依次跳转后，可以使用Ctrl+o快速回到上一次（跳转前）光标所在位置</strong></p></li><li><p>行内跳转</p><ul><li></li></ul></li></ul></li><li><p>复制粘贴</p><ul><li>使用y复制<ul><li>yy——复制整行</li><li>3yy——复制3行</li><li>y^复制至行首，或者y0。（不含光标所在处字符）</li><li>y$复制至行尾。含光标所在处字符。</li><li>yw——复制一个单词</li><li>y2w——复制2个单词</li><li>yG——复制至文本末</li><li>y1G复制至文本开头</li></ul></li><li>使用p粘贴<ul><li>p小写粘贴至光标后（下）</li><li>p大写粘贴至光标前（上）</li></ul></li><li>使用dd剪切<ul><li>ddp快速交换上下行</li></ul></li></ul></li></ul><h2 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h2><ul><li><p>字符替换命令</p><p>| 命令             | 说明                                         |<br>| —————- | ——————————————– |<br>| <code>r</code>+&lt;待替换字母&gt; | 将游标所在字母替换为指定字母                 |<br>| <code>R</code>              | 连续替换，直到按下<code>Esc</code>                      |<br>| <code>cc</code>             | 替换整行，即删除游标所在行，并进入插入模式   |<br>| <code>cw</code>             | 替换一个单词，即删除一个单词，并进入插入模式 |<br>| <code>C</code>(大写)        | 替换游标以后至行末                           |<br>| <code>~</code>              | 反转游标所在字母大小写                       |<br>| <code>u</code>{n}           | 撤销一次或n次操作                            |<br>| <code>U</code>(大写)        | 撤销当前行的所有修改                         |<br>| <code>Ctrl+r</code>         | redo，即撤销undo的操作                       |</p></li><li><p>字符查找命令</p><ul><li>f+keyword ——查找</li><li>普通模式下输入<code>/icmp</code>然后回车即可查找字符串 <code>icmp</code></li><li>普通模式下输入<code>n</code>查找下一个 <code>icmp</code></li><li>普通模式下输入<code>？tcp</code>向上查找字符串 <code>tcp</code></li><li>普通模式下输入<code>N</code>查找上一个出现的 <code>tcp</code></li><li>命令行模式下输入 <code>noh</code> 然后回车即可取消搜索</li><li>普通模式下输入<code>\*</code>寻找游标所在处的单词</li><li>普通模式下输入<code>\#</code>同上，但 <code>\#</code> 是向前（上）找，<code>\*</code>则是向后（下）找</li><li>普通模式下输入<code>g\*</code>同<code>\*</code> ，但部分符合该单词即可</li><li>普通模式下输入<code>g\#</code>同<code>\#</code> ，但部分符合该单词即可</li></ul><p>以上查找<code>n</code>,<code>N</code> 的继续查找命令依然可以用</p></li><li><p>shiftwidth命令</p><ul><li>:set shiftwidth?——获取目前设置的缩进值</li><li>:set shiftwidth=10——设置缩进为10个字符</li></ul></li><li><p>调整文本位置</p><ul><li>:ce——本行内容居中</li><li>:ri——本行内容靠右</li><li>:le——本行内容靠左</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vim命令模式&quot;&gt;&lt;a href=&quot;#vim命令模式&quot; class=&quot;headerlink&quot; title=&quot;vim命令模式&quot;&gt;&lt;/a&gt;vim命令模式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;普通模式（默认，其他模式按&lt;code&gt;esc&lt;/code&gt;返回）&lt;/li&gt;
&lt;li&gt;命令行模式（按&lt;code&gt;：&lt;/code&gt;进入）&lt;/li&gt;
&lt;li&gt;插入模式（按&lt;code&gt;a&lt;/code&gt;或者&lt;code&gt;i&lt;/code&gt;进入）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;命令行模式输入&lt;code&gt;wq&lt;/code&gt;回车后保存并退出vim&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="其它" scheme="http://gajya.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>SOAP请求步骤</title>
    <link href="http://gajya.github.io/2019/05/16/SOAP%E8%AF%B7%E6%B1%82%E6%AD%A5%E9%AA%A4/"/>
    <id>http://gajya.github.io/2019/05/16/SOAP请求步骤/</id>
    <published>2019-05-16T11:05:01.000Z</published>
    <updated>2019-05-21T02:26:26.150Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用postman构造soap请求的方法：</strong></p><ol><li><p>将请求方法设置为POST。</p></li><li><p>打开Raw编辑器，并将body类型设置为“text / xml”。</p></li><li><p>在请求体中，根据需要定义SOAP Envelope，header和body标签。首先给出必要的SOAP Envelope标签，并定义所有的命名空间。给SOAP header和body。应在SOAP体中指定SOAP方法（操作）的名称。<br>代码中的实现：</p></li><li><p>先在cur-system.js和cur-system-url.js（三个环境都需要配置）里进行配置。</p></li><li><p>设置params，一般是这种形式：</p><ol><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span> <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">ns1:CSBHeader</span> <span class="attr">soapenv:actor</span>=<span class="string">"http://schemas.xmlsoap.org/soap/actor/next"</span> <span class="attr">soapenv:mustUnderstand</span>=<span class="string">"0"</span> <span class="attr">xmlns:ns1</span>=<span class="string">"http://www.shtel.com.cn/csb/v2/"</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ServiceName</span>&gt;</span>QueryPointsInfoByCrmId<span class="tag">&lt;/<span class="name">ServiceName</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ServiceVer</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">ServiceVer</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">Consumer</span>&gt;</span>CRMORDWEB<span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">RequestTime</span>&gt;</span>2013-12-19T07:53:01.198Z<span class="tag">&lt;/<span class="name">RequestTime</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">ns1:CSBHeader</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">m:webSearchExchangePoints</span> <span class="attr">xmlns:m</span>=<span class="string">"http://src.ws.com"</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">ScoreInfo</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">CrmId</span>&gt;</span>$&#123;this.custInfo.custNumber&#125;<span class="tag">&lt;/<span class="name">CrmId</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">ScoreInfo</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">m:webSearchExchangePoints</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="6"><li><p>调取接口方法</p></li><li><p>获取数据需要先进行格式化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> xml2js <span class="keyword">from</span> <span class="string">"xml2js"</span> <span class="comment">// 注意：xml2js需要先引入</span></span><br><span class="line"> </span><br><span class="line"> curApi.queryPointsInfoByCrmId(param).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> parser = <span class="keyword">new</span> xml2js.Parser();</span><br><span class="line">   parser.parseString(res.data,(err,result)=&gt;&#123;</span><br><span class="line">     <span class="keyword">this</span>.integral = result.ScoreInfo.body[<span class="number">0</span>].PointsUseable[<span class="number">0</span>] <span class="comment">// 当前可用积分</span></span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用postman构造soap请求的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将请求方法设置为POST。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开Raw编辑器，并将body类型设置为“text / xml”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="其它" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
      <category term="其它" scheme="http://gajya.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的工作流程</title>
    <link href="http://gajya.github.io/2019/05/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://gajya.github.io/2019/05/09/浏览器的工作流程/</id>
    <published>2019-05-09T09:52:11.000Z</published>
    <updated>2019-05-10T07:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的主要功能是将用户选择得web资源呈现出来，从服务器请求资源，并将其显示在浏览器窗口中，资源格式包括html、PDF、image、svg以及其他格式。用户通过<code>URI(统一资源标识符)</code>来指定所请求资源的位置。</p><h2 id="浏览器的主要构成"><a href="#浏览器的主要构成" class="headerlink" title="浏览器的主要构成"></a>浏览器的主要构成</h2><ol><li><strong>用户界面</strong>——包括地址栏、后退/前进按钮/书签目录等，除了用来显示请求页面的主窗口外的其他部分</li><li><strong>浏览器引擎</strong>——可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，（用来查询及操作渲染引擎的接口）</li><li><strong>渲染引擎</strong>——用来显示请求的内容，例如html，它负责解析html及css，并将解析后的结果显示出来。我们常说的浏览器内核主要指的是渲染引擎。</li><li><strong>网络</strong>——用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li><li><strong>js解释器</strong>——用来解释执行js脚本的模块，比如V8引擎、javascriptCore</li><li><strong>UI后端</strong>——用来绘制基本的浏览器窗口内控件，如输入框/按钮/单选按钮等，根据浏览器不同绘制的视觉效果也不同，但是功能都是一样的</li><li><strong>数据存储</strong>——浏览器再硬盘中保存cookie、localStorage等各种数据，可以通过浏览器引擎提供的API进行调用</li></ol><p><img src="/2019/05/09/浏览器的工作流程/浏览器主要结构.png" alt="浏览器主要结构"></p>   <a id="more"></a><p>作为前端开发人员，我们需要<code>重点理解渲染引擎的工作原理</code>，<code>灵活应用数据存储技术</code>，在实际项目开发中会经常涉及到这两个部分，尤其是在做<code>项目性能优化</code>时，理解浏览器渲染引擎的工作原理尤为重要。而其他部分则是由浏览器自行管理的，开发者能控制的地方较少。</p><p><strong><em>需要注意的是，不同于大部分浏览器，Chrome为每个Tab分配了各自的渲染引擎实例，每个Tab就是一个独立的进程。</em></strong></p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。</p><p>默认情况下，渲染引擎可以显示html、xml文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用PDF<a href="http://book.2cto.com/" target="_blank" rel="noopener">阅读</a>器插件，可以显示PDF格式。</p><p>当然，渲染引擎最主要的用途——显示应用了CSS之后的html及图片。</p><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>渲染引擎通过网络获得所请求文档的内容后的主流程：</p><p>解析html以构建dom树——构建render树——布局render树——绘制render树</p><p><img src="/2019/05/09/浏览器的工作流程/渲染引擎主流程.png" alt="渲染引擎主流程"></p><p><strong>解析HTML构建DOM树</strong>时渲染引擎会将html文件的便签元素解析成多个dom元素对象节点，并且将这些节点根据父子关系组成一个树结构</p><p>同时，css文件被解析成css规则表，然后将每条css规则按照【从右向左】的方式在DOM树上进行逆向匹配，生成一个具有样式规则描述的DOM渲染树。</p><p>这些样式信息以及html中的可见性指令将被用来构建另一棵树——render树</p><p>render树构建好之后，会执行布局过程，它将确定每个节点在屏幕上的确切坐标。</p><p>绘制即是遍历render树，并使用UI后端层绘制每个节点</p><p><strong><em>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</em></strong></p><p><img src="/2019/05/09/浏览器的工作流程/渲染引擎基本流程.png" alt="webkit渲染引擎主流程"></p><p>webkit内核工作主流程</p><h4 id="解析-Parsing-general"><a href="#解析-Parsing-general" class="headerlink" title="解析 Parsing-general"></a>解析 Parsing-general</h4><p>解析一个文档就是把它转换成计算机可以理解和使用的东西。解析的结果通常是表达文档结构的节点树，称为解析树或语法树。</p><h4 id="文法-Grammars"><a href="#文法-Grammars" class="headerlink" title="文法 Grammars"></a>文法 Grammars</h4><p>解析基于文档依据的语法规则——文档的语言或格式。</p><h4 id="解析器——词法解析器"><a href="#解析器——词法解析器" class="headerlink" title="解析器——词法解析器"></a>解析器——词法解析器</h4><p>解析分为两个子过程——语法分析和词法分析</p><p><code>词法分析</code>就是将输入分解为符号，符号是语言的词汇表——基本有效单元的集合。对于人类语言来说，相当于我们字典中出现的所有单词。</p><p><code>语法分析</code>指对语言应用语法规则。</p><p>解析过程是迭代的，具体详情请<a href="https://www.2cto.com/kf/201202/118111.html" target="_blank" rel="noopener">点击此处</a></p><h4 id="转换-Translation"><a href="#转换-Translation" class="headerlink" title="转换 Translation"></a>转换 Translation</h4><p>解析一般在转换中使用——将输入文档转换为另一种格式。例如编译，编译器在将一段源码编译为机器码的时候，先将源码解析为解析树，然后将该树转换为一个机器码文档。</p><h4 id="解析器类型-Types-of-parsers"><a href="#解析器类型-Types-of-parsers" class="headerlink" title="解析器类型 Types of parsers(????????????????????????)"></a>解析器类型 Types of parsers(????????????????????????)</h4><p>有两种基本的解析器——自顶向下解析以及自底向上解析，</p><p>​     ?????????????????????????????</p><p><div style="width: 200px;"><img src="/2019/05/09/浏览器的工作流程/why.jpg" alt="微信图片_20190510145457"></div><br>自底向上解析？？？？？？？？？？？？</p><h4 id="自动化解析"><a href="#自动化解析" class="headerlink" title="自动化解析"></a>自动化解析</h4><p>解析器生成器是一种工具，可以自动生成解析器，只需要指定语言的文法——词汇及语法规则，它就可以生成一个解析器。</p><p>webkit使用两个解析生成器——用于创建语法分析器的Flex和创建解析器的Bison。Flex的输入是一个包含了符号定义的正则表达式，Bison的输入是用<a href="https://www.jianshu.com/p/15efcb0c06c8" target="_blank" rel="noopener">BNF格式</a>表示的语法规则。</p><h4 id="HTML解析器"><a href="#HTML解析器" class="headerlink" title="HTML解析器"></a>HTML解析器</h4><p>html解析器的工作是将html标识解析为解析树</p><h4 id="非上下文无关文法"><a href="#非上下文无关文法" class="headerlink" title="非上下文无关文法"></a>非上下文无关文法</h4><p>由于所有的传统解析方式都不适用于html，html不能简单的用解析所需要的上下文无关文法来定义。</p><p>html的正式的格式定义——DTD(Document Type Definition 文档类型定义)——它不是上下文无关文法。html接近于XML，但是比xml更宽容，是一种soft语法。</p><p>因为它的宽容使得很难去写一个格式化的文法，所以既不能使用传统的解析器解析，也不能使用xml解析器解析。</p><h4 id="DOM（Document-Object-Model）"><a href="#DOM（Document-Object-Model）" class="headerlink" title="DOM（Document Object Model）"></a>DOM（Document Object Model）</h4><p>输出的树，即解析树，是由DOM元素以及属性节点组成的。DOM和标签基本是一一对应的关系。</p><h4 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h4><p>html不能被一般的自顶向下或者自底向上的解析器所解析</p><p>原因是：</p><ol><li>这门语言本身的宽容性</li><li>浏览器对一些常见的非法html有容错机制</li><li>解析过程是往复的，通常源码不会在解析过程中发生改变，但是在html中，脚本标签包含的<code>document.write</code>可能会添加标签，这说明在解析过程中实际修改了输入，不能使用正则解析技术，浏览器为html定制了专属的解析器。</li></ol><p>html5规范中描述了这个解析算法，包括两个阶段——<code>符号化</code>和<code>构建树</code>。</p><p><strong>符号化即词法分析的过程</strong>，将输入解析为符号，html的符号包括开始标签、结束标签、属性名和属性值。</p><p>符号识别器识别出符号后，将其传递给树构建器，并读取下一个字符，一直这样操作直到处理完所有输入。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的主要功能是将用户选择得web资源呈现出来，从服务器请求资源，并将其显示在浏览器窗口中，资源格式包括html、PDF、image、svg以及其他格式。用户通过&lt;code&gt;URI(统一资源标识符)&lt;/code&gt;来指定所请求资源的位置。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的主要构成&quot;&gt;&lt;a href=&quot;#浏览器的主要构成&quot; class=&quot;headerlink&quot; title=&quot;浏览器的主要构成&quot;&gt;&lt;/a&gt;浏览器的主要构成&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;用户界面&lt;/strong&gt;——包括地址栏、后退/前进按钮/书签目录等，除了用来显示请求页面的主窗口外的其他部分&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;浏览器引擎&lt;/strong&gt;——可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，（用来查询及操作渲染引擎的接口）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;渲染引擎&lt;/strong&gt;——用来显示请求的内容，例如html，它负责解析html及css，并将解析后的结果显示出来。我们常说的浏览器内核主要指的是渲染引擎。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络&lt;/strong&gt;——用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;js解释器&lt;/strong&gt;——用来解释执行js脚本的模块，比如V8引擎、javascriptCore&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI后端&lt;/strong&gt;——用来绘制基本的浏览器窗口内控件，如输入框/按钮/单选按钮等，根据浏览器不同绘制的视觉效果也不同，但是功能都是一样的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据存储&lt;/strong&gt;——浏览器再硬盘中保存cookie、localStorage等各种数据，可以通过浏览器引擎提供的API进行调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/2019/05/09/浏览器的工作流程/浏览器主要结构.png&quot; alt=&quot;浏览器主要结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue 组件调用组件报错：did you register the component correctly?</title>
    <link href="http://gajya.github.io/2019/05/06/vue-%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6%E6%8A%A5%E9%94%99%EF%BC%9Adid-you-register-the-component-correctly/"/>
    <id>http://gajya.github.io/2019/05/06/vue-组件调用组件报错：did-you-register-the-component-correctly/</id>
    <published>2019-05-06T02:12:11.000Z</published>
    <updated>2019-05-06T02:19:07.179Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一般报这个错的原因都是我们使用了未注册的组件。</strong></p><p>Vue.js 提供了 2 种组件的注册方式，全局注册和局部注册。</p><ol><li>先引入（确保路径没问题）</li><li>components注册</li><li>引入的组件保持name一致<a id="more"></a></li></ol><p><strong>二般情况，请先查看引入的该组件下是否有其他子组件，如果子组件报错，也可能会导致报这个错</strong></p><p><img src="/2019/05/06/vue-组件调用组件报错：did-you-register-the-component-correctly/1557108559407.png" alt="1557108559407"></p><p>举个栗子：</p><p>以下，UseCustomers组件下引入的chooseUser组件中，vuex中的actions未引入，导致的报错。。。</p><p><img src="/2019/05/06/vue-组件调用组件报错：did-you-register-the-component-correctly/1557107758929.png" alt="1557107758929"></p><p><strong>情况三，可能是你的<code>script</code>标签未闭合，请自行检查</strong></p><p><strong>情况四，可能是你的<code>template</code>标签里的html代码有误，例如标签未闭合</strong></p><p><strong>情况五，局部注册时候，是<code>components</code>，请检查是否漏了<code>&#39;s&#39;</code></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;一般报这个错的原因都是我们使用了未注册的组件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vue.js 提供了 2 种组件的注册方式，全局注册和局部注册。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先引入（确保路径没问题）&lt;/li&gt;
&lt;li&gt;components注册&lt;/li&gt;
&lt;li&gt;引入的组件保持name一致&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用饿了么表单报错，提示filed命名冲突</title>
    <link href="http://gajya.github.io/2019/04/28/%E4%BD%BF%E7%94%A8%E9%A5%BF%E4%BA%86%E4%B9%88%E8%A1%A8%E5%8D%95%E6%8A%A5%E9%94%99%EF%BC%8C%E6%8F%90%E7%A4%BAfiled%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81/"/>
    <id>http://gajya.github.io/2019/04/28/使用饿了么表单报错，提示filed命名冲突/</id>
    <published>2019-04-28T07:48:00.000Z</published>
    <updated>2019-04-28T07:53:50.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="饿了么表单报错，vee-validate的（filed）命名冲突"><a href="#饿了么表单报错，vee-validate的（filed）命名冲突" class="headerlink" title="饿了么表单报错，vee-validate的（filed）命名冲突"></a>饿了么表单报错，vee-validate的（filed）命名冲突</h3><p>原因可能是项目使用了vee-validate，请自行检查，如果是，解决方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 饿了么表单报错，vee-validate的命名冲突，利用自定义vee-validate配置解决这个问题</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  aria: <span class="literal">true</span>,</span><br><span class="line">  classNames: &#123;&#125;,</span><br><span class="line">  classes: <span class="literal">false</span>,</span><br><span class="line">  delay: <span class="number">0</span>,</span><br><span class="line">  dictionary: <span class="literal">null</span>,</span><br><span class="line">  errorBagName: <span class="string">'errors'</span>, <span class="comment">// change if property conflicts</span></span><br><span class="line">  events: <span class="string">'input|blur'</span>,</span><br><span class="line">  fieldsBagName: <span class="string">'fields2'</span>, <span class="comment">// 把这个名字改成fields之外的就可以了</span></span><br><span class="line">  i18n: <span class="literal">null</span>, <span class="comment">// the vue-i18n plugin instance</span></span><br><span class="line">  i18nRootKey: <span class="string">'validations'</span>, <span class="comment">// the nested key under which the validation messages will be located</span></span><br><span class="line">  inject: <span class="literal">true</span>,</span><br><span class="line">  locale: <span class="string">'en'</span>,</span><br><span class="line">  validity: <span class="literal">false</span>,</span><br><span class="line">  useConstraintAttrs: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vue安装插件时候，传入配置</span></span><br><span class="line">Vue.use(VeeValidate, config);</span><br></pre></td></tr></table></figure><p>可以利用自定义vee-validate配置解决这个问题，在main.js里加入config配置项</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;饿了么表单报错，vee-validate的（filed）命名冲突&quot;&gt;&lt;a href=&quot;#饿了么表单报错，vee-validate的（filed）命名冲突&quot; class=&quot;headerlink&quot; title=&quot;饿了么表单报错，vee-validate的（filed）
      
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
      <category term="工具" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/tags/vue/"/>
    
      <category term="vue-工具" scheme="http://gajya.github.io/tags/vue-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>mpvue打包没有.json等配置文件的解决方法</title>
    <link href="http://gajya.github.io/2019/03/07/mpvue%E6%89%93%E5%8C%85%E6%B2%A1%E6%9C%89-json%E7%AD%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://gajya.github.io/2019/03/07/mpvue打包没有-json等配置文件的解决方法/</id>
    <published>2019-03-07T02:46:54.000Z</published>
    <updated>2019-04-28T07:57:50.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h2><p>使用vue init mpvue/mpvue-quickstart my-project 初始化项目却报找不到app.json </p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>出错原因：版本问题，最新版本的mpvue 构建出来的代码在 dist/wx 下面</p></blockquote><p>project.config.json里miniprogramRoot 改成 dist/wx/</p><p><a href="https://github.com/mpvue/mpvue-quickstart/commit/3fcca8fb24415a6d3321f967e50a39db7a088508#diff-08ddb1b50abf760ac6ed31dddb878377R8" target="_blank" rel="noopener">GitHub PR</a></p><a id="more"></a><h2 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h2><p>删除了src文件下所有文件，main.js中写config内容，打包后小程序提示查找不到‘app.json’文件。mpvue重新打包，只生成内容文件无配置文件。</p><h2 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>出错原因：版本问题，最新版本的cli程序不再生成json文件了，得自己去写</p></blockquote><p><strong>1. 把packpage.json里的mpvue-loade后面的‘^’去掉，固定版本号，重新安装依赖即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;mpvue-loader&quot;: &quot;^1.0.13&quot;, =&gt; &quot;mpvue-loader&quot;: &quot;1.0.13&quot;,</span><br></pre></td></tr></table></figure><p><strong>2. 自己写就完全ojbk了啊ヽ(｀Д´)ﾉ︵ ┻━┻ ┻━┻ （浪费我的感情）</strong></p><h2 id="指定版本号"><a href="#指定版本号" class="headerlink" title="指定版本号"></a>指定版本号</h2><ul><li>‘2.0.0’ 表示安装指定的版本号，也就是安装2.0.0版本。</li><li>‘~2.0.0’ 表示安装2.0.x的最新版本。</li><li>‘^2.0.0’ 表示安装2.x.x的最新版本。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;情况1&quot;&gt;&lt;a href=&quot;#情况1&quot; class=&quot;headerlink&quot; title=&quot;情况1&quot;&gt;&lt;/a&gt;情况1&lt;/h2&gt;&lt;p&gt;使用vue init mpvue/mpvue-quickstart my-project 初始化项目却报找不到app.json &lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;出错原因：版本问题，最新版本的mpvue 构建出来的代码在 dist/wx 下面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;project.config.json里miniprogramRoot 改成 dist/wx/&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mpvue/mpvue-quickstart/commit/3fcca8fb24415a6d3321f967e50a39db7a088508#diff-08ddb1b50abf760ac6ed31dddb878377R8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub PR&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="小程序" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="小程序" scheme="http://gajya.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="mpvue" scheme="http://gajya.github.io/tags/mpvue/"/>
    
  </entry>
  
  <entry>
    <title>性能优化———浏览器存储</title>
    <link href="http://gajya.github.io/2019/03/05/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E2%80%94%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"/>
    <id>http://gajya.github.io/2019/03/05/性能优化———浏览器存储/</id>
    <published>2019-03-05T09:52:49.000Z</published>
    <updated>2019-03-05T09:52:49.062Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test-post</title>
    <link href="http://gajya.github.io/2019/03/05/test-post/"/>
    <id>http://gajya.github.io/2019/03/05/test-post/</id>
    <published>2019-03-04T16:13:14.000Z</published>
    <updated>2019-03-04T17:29:20.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="test-post"><a href="#test-post" class="headerlink" title="test-post"></a>test-post</h2><p>测试hexo插入图片</p><a id="more"></a><p><img src="/2019/03/05/test-post/vue.png" alt="vue"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;test-post&quot;&gt;&lt;a href=&quot;#test-post&quot; class=&quot;headerlink&quot; title=&quot;test-post&quot;&gt;&lt;/a&gt;test-post&lt;/h2&gt;&lt;p&gt;测试hexo插入图片&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 为何返回[1,NaN,NaN]</title>
    <link href="http://gajya.github.io/2019/02/18/%5B1,%202,%203%5D.map(parseInt)%20%E4%B8%BA%E4%BD%95%E8%BF%94%E5%9B%9E%5B1,NaN,NaN%5D/"/>
    <id>http://gajya.github.io/2019/02/18/[1, 2, 3].map(parseInt) 为何返回[1,NaN,NaN]/</id>
    <published>2019-02-18T09:34:15.000Z</published>
    <updated>2019-03-04T17:28:09.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="“1”-“2”-“3”-map-parseInt-为何返回-1-NaN-NaN"><a href="#“1”-“2”-“3”-map-parseInt-为何返回-1-NaN-NaN" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 为何返回[1,NaN,NaN]"></a>[“1”, “2”, “3”].map(parseInt) 为何返回[1,NaN,NaN]</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(<span class="built_in">parseInt</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>].map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(value, index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 第一轮遍历 parseInt('1', 0) -&gt; 1</span></span><br><span class="line"><span class="comment">// 第二轮遍历 parseInt('2', 1) -&gt; NaN</span></span><br><span class="line"><span class="comment">// 第三轮遍历 parseInt('3', 2) -&gt; NaN</span></span><br></pre></td></tr></table></figure><p>parseInt(<em>string</em>, <em>radix</em>) 的参数radix必须介于2~36之间，而且字符串string中的数字不能大于radix才能正确返回数字结果值。</p><a id="more"></a><h3 id="parseInt语法"><a href="#parseInt语法" class="headerlink" title="parseInt语法"></a>parseInt语法</h3><blockquote><p>parseInt(string,  radix)</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。要被解析的字符串。</td></tr><tr><td>radix</td><td>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。<br> 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。</td></tr></tbody></table><p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。 |</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;“1”-“2”-“3”-map-parseInt-为何返回-1-NaN-NaN&quot;&gt;&lt;a href=&quot;#“1”-“2”-“3”-map-parseInt-为何返回-1-NaN-NaN&quot; class=&quot;headerlink&quot; title=&quot;[“1”, “2”, “3”].map(parseInt) 为何返回[1,NaN,NaN]&quot;&gt;&lt;/a&gt;[“1”, “2”, “3”].map(parseInt) 为何返回[1,NaN,NaN]&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;].map(&lt;span class=&quot;built_in&quot;&gt;parseInt&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 相当于&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;2&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;3&#39;&lt;/span&gt;].map(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;value, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;parseInt&lt;/span&gt;(value, index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第一轮遍历 parseInt(&#39;1&#39;, 0) -&amp;gt; 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第二轮遍历 parseInt(&#39;2&#39;, 1) -&amp;gt; NaN&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 第三轮遍历 parseInt(&#39;3&#39;, 2) -&amp;gt; NaN&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;parseInt(&lt;em&gt;string&lt;/em&gt;, &lt;em&gt;radix&lt;/em&gt;) 的参数radix必须介于2~36之间，而且字符串string中的数字不能大于radix才能正确返回数字结果值。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/es6/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>什么是NPM</title>
    <link href="http://gajya.github.io/2019/01/22/%E4%BB%80%E4%B9%88%E6%98%AFNPM/"/>
    <id>http://gajya.github.io/2019/01/22/什么是NPM/</id>
    <published>2019-01-22T01:27:15.000Z</published>
    <updated>2019-03-04T17:29:51.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是NPM"><a href="#什么是NPM" class="headerlink" title="什么是NPM"></a>什么是NPM</h2><p>NPM（node package manager），通常称作node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。</p><p>NPM是基于couchdb一个数据库，详细记录了每个包的信息（作者、版本、依赖、授权信息等）。</p><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">NPM官网</a></p><a id="more"></a><h3 id="NPM安装"><a href="#NPM安装" class="headerlink" title="NPM安装"></a>NPM安装</h3><p><strong>本地安装：</strong></p><p>package会被下载到当前所在目录，./node_modules下（运行npm时所在的目录），只能当前目录下使用，安装包放在，可以通过require()来引入</p><p><strong>全局安装：</strong></p><p>package会被下载到待定的系统目录下（安装包放在 /usr/local 下），安装的package能在所有目录下使用，可以直接在命令行里使用</p><h4 id="npm-i-package-本地安装"><a href="#npm-i-package-本地安装" class="headerlink" title="npm i package(本地安装)"></a>npm i package(本地安装)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-cli</span><br></pre></td></tr></table></figure><p>安装结束后，当前目录下回多出一个 <code>node_modules</code> 目录，<code>webpack-cli</code>就安装在里面。同时注意控制台输出的信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ webpack-cli@<span class="number">3.1</span><span class="number">.2</span>  <span class="comment">// 当前安装的package为webpack-cli，版本是3.1.2</span></span><br></pre></td></tr></table></figure><h4 id="npm-i-g-package-全局安装"><a href="#npm-i-g-package-全局安装" class="headerlink" title="npm i -g package(全局安装)"></a>npm i -g package(全局安装)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack-cli</span><br></pre></td></tr></table></figure><h3 id="npm包管理"><a href="#npm包管理" class="headerlink" title="npm包管理"></a>npm包管理</h3><h4 id="安装最新版本"><a href="#安装最新版本" class="headerlink" title="安装最新版本"></a>安装最新版本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i package-name</span><br></pre></td></tr></table></figure><h4 id="安装1-1-0版本的包"><a href="#安装1-1-0版本的包" class="headerlink" title="安装1.1.0版本的包"></a>安装1.1.0版本的包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i package-name@<span class="string">"1.1.0"</span></span><br></pre></td></tr></table></figure><p>可以通过package.json进行安装，将项目依赖的包都在package.json这个文件里声明，通过以下命令搞定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall package-name</span><br></pre></td></tr></table></figure><h4 id="卸载某个版本"><a href="#卸载某个版本" class="headerlink" title="卸载某个版本"></a>卸载某个版本</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall package-name@<span class="string">"1.1.0"</span></span><br></pre></td></tr></table></figure><h4 id="查看安装的包"><a href="#查看安装的包" class="headerlink" title="查看安装的包"></a>查看安装的包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls</span><br></pre></td></tr></table></figure><h4 id="查看特定包的信息"><a href="#查看特定包的信息" class="headerlink" title="查看特定包的信息"></a>查看特定包的信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls package-name</span><br></pre></td></tr></table></figure><h4 id="查看更详细的信息"><a href="#查看更详细的信息" class="headerlink" title="查看更详细的信息"></a>查看更详细的信息</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info package-name</span><br></pre></td></tr></table></figure><h4 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm help</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是NPM&quot;&gt;&lt;a href=&quot;#什么是NPM&quot; class=&quot;headerlink&quot; title=&quot;什么是NPM&quot;&gt;&lt;/a&gt;什么是NPM&lt;/h2&gt;&lt;p&gt;NPM（node package manager），通常称作node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。&lt;/p&gt;
&lt;p&gt;NPM是基于couchdb一个数据库，详细记录了每个包的信息（作者、版本、依赖、授权信息等）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NPM官网&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="node" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="node" scheme="http://gajya.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>class类</title>
    <link href="http://gajya.github.io/2018/12/29/class/"/>
    <id>http://gajya.github.io/2018/12/29/class/</id>
    <published>2018-12-29T09:34:14.000Z</published>
    <updated>2019-03-04T17:28:43.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><h3 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><p>如果定义了一个空的类Point，Javascript引擎会自动为它添加一个空的<code>contructor</code>方法。</p><p><code>contructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p><p>类必须用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo()</span><br><span class="line"><span class="comment">// Uncaught TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure><h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x</span><br><span class="line">        <span class="keyword">this</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    toString () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'x: '</span> + <span class="keyword">this</span>.x + <span class="string">'; y: '</span> + <span class="keyword">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">point.toString() <span class="comment">// x: 1; y: 2</span></span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>类所有的实例共享一个原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point()</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point()</span><br><span class="line"></span><br><span class="line">p1._proto_ === p2._proto_ === Point.protype</span><br></pre></td></tr></table></figure><p>可以通过实例的<code>__proto__</code>属性为“类”添加方法，<strong>不推荐！！！</strong>使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><p>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    contructor() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    [methodName] () &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p><h3 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h3><p>类支持使用表达式的形式定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">    getClassName () &#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name <span class="comment">// 相当于MyClass.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在 Class 的内部代码可用，指代当前类。如果内容没有使用到<code>Me</code>可以直接省略。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p>采用 Class 表达式，可以写出立即执行的 Class。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>)</span><br><span class="line">person.sayName() <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p>类和模块的内部默认就是严格模式。</p></li><li><p>不存在<code>变量提升（hoist）</code>，必须保证子类在父类之后定义</p></li><li><p>name属性，name属性总是返回紧跟在<code>class</code>关键字后面的类名</p></li><li><p><code>Generator</code>方法，如果某个方法前面加上<code>（*）</code>号就表示该方法是一个Generator函数。<strong>？？？？？？</strong></p></li><li><p><code>this</code>指向，类的方法内部如果有<code>this</code>，默认指向类的实例。一旦单独使用该方法，很可能报错。<strong>（？？？？）</strong></p><p><strong>解决方法</strong></p><ul><li>在构造方法中绑定<code>this</code>，这样就没问题了</li><li>使用箭头函数</li><li>使用<code>Proxy</code>，获取方法适合，自动绑定<code>this</code></li></ul></li></ol><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;class类&quot;&gt;&lt;a href=&quot;#class类&quot; class=&quot;headerlink&quot; title=&quot;class类&quot;&gt;&lt;/a&gt;class类&lt;/h2&gt;&lt;h3 id=&quot;constructor方法&quot;&gt;&lt;a href=&quot;#constructor方法&quot; class=&quot;headerlink&quot; title=&quot;constructor方法&quot;&gt;&lt;/a&gt;constructor方法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;constructor&lt;/code&gt;方法是类的默认方法，通过&lt;code&gt;new&lt;/code&gt;命令生成对象实例时，自动调用该方法。一个类必须有&lt;code&gt;constructor&lt;/code&gt;方法，如果没有显式定义，一个空的&lt;code&gt;constructor&lt;/code&gt;方法会被默认添加。&lt;/p&gt;
&lt;p&gt;如果定义了一个空的类Point，Javascript引擎会自动为它添加一个空的&lt;code&gt;contructor&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contructor&lt;/code&gt;方法默认返回实例对象（即&lt;code&gt;this&lt;/code&gt;），完全可以指定返回另外一个对象。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/es6/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Array数组扩展</title>
    <link href="http://gajya.github.io/2018/12/29/Array%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95/"/>
    <id>http://gajya.github.io/2018/12/29/Array数组扩展/</id>
    <published>2018-12-29T07:25:12.000Z</published>
    <updated>2019-03-04T17:28:18.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Array数组扩展"><a href="#Array数组扩展" class="headerlink" title="Array数组扩展"></a>Array数组扩展</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p><a id="more"></a><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>Array.of()方法用于将一组值转为数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure><p>Array.of()总是返回参数值组成的数组，如果没有参数，就返回一个空数组</p><p>模拟Array.of()功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-和findIndex"><a href="#find-和findIndex" class="headerlink" title="find()和findIndex()"></a>find()和findIndex()</h3><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>上面的代码中，<code>find</code>函数接收了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象。</p><p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf</code>方法的不足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>fill()方法使用给定值，填充一个数组。</p><p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位<strong>之前</strong>结束。</p><p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p><h3 id="entries-keys-values"><a href="#entries-keys-values" class="headerlink" title="entries(), keys(), values()"></a>entries(), keys(), values()</h3><p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。ES2016 引入了该方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原先使用的indexOf()方法，有两个缺点</p><ol><li>不够语义化</li><li>内部使用的严格相等运算符（<code>===</code>）进行判断，会对<code>NaN</code>进行误判</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> contains = <span class="function">(<span class="params">(</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">    ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">    : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">)();</span><br><span class="line">contains([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'baz'</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p><ul><li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li><li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li></ul><h3 id="flat-，flatMap"><a href="#flat-，flatMap" class="headerlink" title="flat()，flatMap()"></a>flat()，flatMap()</h3><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.flat()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,[3,4]]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat()</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Array数组扩展&quot;&gt;&lt;a href=&quot;#Array数组扩展&quot; class=&quot;headerlink&quot; title=&quot;Array数组扩展&quot;&gt;&lt;/a&gt;Array数组扩展&lt;/h2&gt;&lt;h3 id=&quot;解构赋值&quot;&gt;&lt;a href=&quot;#解构赋值&quot; class=&quot;headerlink&quot; title=&quot;解构赋值&quot;&gt;&lt;/a&gt;解构赋值&lt;/h3&gt;&lt;h3 id=&quot;Array-from&quot;&gt;&lt;a href=&quot;#Array-from&quot; class=&quot;headerlink&quot; title=&quot;Array.from&quot;&gt;&lt;/a&gt;Array.from&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Array.from&lt;/code&gt;方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/es6/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>async函数</title>
    <link href="http://gajya.github.io/2018/12/29/async%E5%87%BD%E6%95%B0/"/>
    <id>http://gajya.github.io/2018/12/29/async函数/</id>
    <published>2018-12-29T05:55:12.000Z</published>
    <updated>2019-03-04T17:28:30.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>它就是Generator函数的语法糖。</p><p>Generator 函数，依次读取两个文件。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><ol><li>内置执行器</li></ol><p>Generator函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是<code>async</code>函数的执行和普通函数一模一样，只要一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile()</span><br></pre></td></tr></table></figure><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><ol start="2"><li>更好的语义</li></ol><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><ol start="3"><li>更广的适用性</li></ol><p><code>co</code>模块，<code>yield</code>命令后面只能是Thunk函数或者Promise对象，而<code>async</code>函数的<code>await</code>命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成resolved的Promise对象）。</p><ol start="3"><li>返回值是Promise</li></ol><p><code>async</code>函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。可以用<code>then</code>方法指定下一步的操作。</p><p><code>async</code>函数可以看作多个异步操作，包装成的一个Promise对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><hr><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> foo() &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">'avatars'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> getAvatar(name) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).then(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="Promise对象的状态变化"><a href="#Promise对象的状态变化" class="headerlink" title="Promise对象的状态变化"></a>Promise对象的状态变化</h3><p><code>async</code>函数返回的Promise对象，必须等到内部所有的<code>await</code>命令后面的Promise对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。即只有<code>async</code>内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><h3 id="await命令"><a href="#await命令" class="headerlink" title="await命令"></a>await命令</h3><p>正常情况下，<code>await</code>命令后面是一个Promise对象，返回该对象的结果。如果不是Promise对象，就直接返回对应的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="comment">// return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。<code>resolve</code>方法前面要加上<code>return</code>，否则会返回<code>undefined</code></p><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ol><li><code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以建议把<code>await</code>命令放在<code>try...catch</code>代码块中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise()</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>async 函数可以保留运行堆栈。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;async函数&quot;&gt;&lt;a href=&quot;#async函数&quot; class=&quot;headerlink&quot; title=&quot;async函数&quot;&gt;&lt;/a&gt;async函数&lt;/h2&gt;&lt;p&gt;它就是Generator函数的语法糖。&lt;/p&gt;
&lt;p&gt;Generator 函数，依次读取两个文件。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/es6/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Set</title>
    <link href="http://gajya.github.io/2018/12/26/Set/"/>
    <id>http://gajya.github.io/2018/12/26/Set/</id>
    <published>2018-12-26T08:09:22.000Z</published>
    <updated>2019-03-04T17:29:09.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="利用Set"><a href="#利用Set" class="headerlink" title="利用Set"></a>利用Set</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>可以通过<code>add</code>方法向Set结构加入成员，结果表明Set结构不会添加重复的值。</p><p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.size <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>去除数组重复成员的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</p><p>Set 内部判断<code>NaN</code>等于自身，精确相等运算符认为<code>NaN</code>不等于自身。</p><p><strong>另外，两个对象总是不相等的。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值</p><h3 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h3><p>属性：</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>方法：</p><ul><li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>clear()</code>：清除所有成员，没有返回值。</li></ul><p>判断是否包括一个键：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = &#123;</span><br><span class="line">  <span class="string">'width'</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">'height'</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties[someName]) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">properties.add(<span class="string">'width'</span>);</span><br><span class="line">properties.add(<span class="string">'height'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties.has(someName)) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><ul><li><code>keys()</code>：返回键名的遍历器</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><p><strong>（1）keys()，values()，entries()</strong></p><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><p><code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>（2）forEach()</strong></p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p><strong>（3）遍历的应用</strong></p><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">Array</span>.from(set, val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>·······················待续························</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Set&quot;&gt;&lt;a href=&quot;#Set&quot; class=&quot;headerlink&quot; title=&quot;Set&quot;&gt;&lt;/a&gt;Set&lt;/h2&gt;&lt;h3 id=&quot;利用Set&quot;&gt;&lt;a href=&quot;#利用Set&quot; class=&quot;headerlink&quot; title=&quot;利用Set&quot;&gt;&lt;/a&gt;利用Set&lt;/h3&gt;&lt;p&gt;ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。&lt;/p&gt;
&lt;p&gt;Set 本身是一个构造函数，用来生成 Set 数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue本质</title>
    <link href="http://gajya.github.io/2018/12/20/Vue%E6%9C%AC%E8%B4%A8/"/>
    <id>http://gajya.github.io/2018/12/20/Vue本质/</id>
    <published>2018-12-20T05:35:45.000Z</published>
    <updated>2019-03-04T17:29:32.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h2><h3 id="Vue初始化"><a href="#Vue初始化" class="headerlink" title="Vue初始化"></a>Vue初始化</h3><p>Vue实际上就是一个用 Function 实现的类，我们只能通过 <code>new Vue</code> 去实例化它。</p><p>有些同学看到这不禁想问，为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多 <code>xxxMixin</code> 的函数调用，并把 <code>Vue</code> 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。</p><a id="more"></a><h3 id="initGlobalAPI"><a href="#initGlobalAPI" class="headerlink" title="initGlobalAPI"></a>initGlobalAPI</h3><p>Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 <code>Vue</code> 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中。</p><p>Vue 官网中关于全局 API 都可以在这个文件里找到。有一点要注意的是，<code>Vue.util</code> 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节的目的是让同学们对 Vue 是什么有一个直观的认识，它本质上就是一个用 Function 实现的 Class，然后它的原型 prototype 以及它本身都扩展了一系列的方法和属性</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从入口开始&quot;&gt;&lt;a href=&quot;#从入口开始&quot; class=&quot;headerlink&quot; title=&quot;从入口开始&quot;&gt;&lt;/a&gt;从入口开始&lt;/h2&gt;&lt;h3 id=&quot;Vue初始化&quot;&gt;&lt;a href=&quot;#Vue初始化&quot; class=&quot;headerlink&quot; title=&quot;Vue初始化&quot;&gt;&lt;/a&gt;Vue初始化&lt;/h3&gt;&lt;p&gt;Vue实际上就是一个用 Function 实现的类，我们只能通过 &lt;code&gt;new Vue&lt;/code&gt; 去实例化它。&lt;/p&gt;
&lt;p&gt;有些同学看到这不禁想问，为何 Vue 不用 ES6 的 Class 去实现呢？我们往后看这里有很多 &lt;code&gt;xxxMixin&lt;/code&gt; 的函数调用，并把 &lt;code&gt;Vue&lt;/code&gt; 当参数传入，它们的功能都是给 Vue 的 prototype 上扩展一些方法，Vue 按功能把这些扩展分散到多个模块中去实现，而不是在一个模块里实现所有，这种方式是用 Class 难以实现的。这么做的好处是非常方便代码的维护和管理，这种编程技巧也非常值得我们去学习。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>process.env.NODE_ENV</title>
    <link href="http://gajya.github.io/2018/12/18/process.env.NODE_ENV/"/>
    <id>http://gajya.github.io/2018/12/18/process.env.NODE_ENV/</id>
    <published>2018-12-18T02:17:12.000Z</published>
    <updated>2019-03-04T17:29:01.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="process-env-NODE-ENV"><a href="#process-env-NODE-ENV" class="headerlink" title="process.env.NODE_ENV"></a>process.env.NODE_ENV</h2><p>最近在看Vue源码解析，看到下面的代码</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>Node中的<a href="http://nodejs.cn/api/process.html#process_process_env" target="_blank" rel="noopener">process.env</a>官方文档</p><p>返回用户的环境信息。</p><p>在node环境下执行<code>process env</code>，返回一个如下对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  TERM: <span class="string">'xterm-256color'</span>,</span><br><span class="line">  SHELL: <span class="string">'/usr/local/bin/bash'</span>,</span><br><span class="line">  USER: <span class="string">'maciej'</span>,</span><br><span class="line">  PATH: <span class="string">'~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'</span>,</span><br><span class="line">  PWD: <span class="string">'/Users/maciej'</span>,</span><br><span class="line">  EDITOR: <span class="string">'vim'</span>,</span><br><span class="line">  SHLVL: <span class="string">'1'</span>,</span><br><span class="line">  HOME: <span class="string">'/Users/maciej'</span>,</span><br><span class="line">  LOGNAME: <span class="string">'maciej'</span>,</span><br><span class="line">  _: <span class="string">'/usr/local/bin/node'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以修改这个对象，但是修改的内容不会影响到进程之外。</p><p>为 <code>process.env</code> 新增属性时会将属性的值转换成字符串。 在未来的版本中，如果属性的值不是字符串、数字或布尔值，则可能抛出错误。</p><p>使用 <code>delete</code> 可以从 <code>process.env</code> 中删除属性。</p><p>在 Windows 上，环境变量不区分大小写。</p><h3 id="process-env-NODE-ENV是一个完全人为定义的"><a href="#process-env-NODE-ENV是一个完全人为定义的" class="headerlink" title="process.env.NODE_ENV是一个完全人为定义的"></a>process.env.NODE_ENV是一个完全人为定义的</h3><p>直接写在js文件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.env.NODE_ENV = <span class="string">'production'</span>;</span><br></pre></td></tr></table></figure><p>然后在<code>package.json</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "set NODE_ENV=dev &amp;&amp; node app.js"</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;process-env-NODE-ENV&quot;&gt;&lt;a href=&quot;#process-env-NODE-ENV&quot; class=&quot;headerlink&quot; title=&quot;process.env.NODE_ENV&quot;&gt;&lt;/a&gt;process.env.NODE_ENV&lt;/h2&gt;&lt;p&gt;最近在看Vue源码解析，看到下面的代码&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="node" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/node/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="node" scheme="http://gajya.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Less</title>
    <link href="http://gajya.github.io/2018/12/17/Less/"/>
    <id>http://gajya.github.io/2018/12/17/Less/</id>
    <published>2018-12-17T09:21:11.000Z</published>
    <updated>2019-03-04T17:28:52.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><p>less是一种<code>动态</code>样式<code>语言</code>。</p><p>less将css赋予了动态语言的特性，如<strong>变量</strong>、<strong>继承</strong>、<strong>运算</strong>、<strong>函数</strong>。less既可以在<strong>客户端</strong>运行（支持IE6+，Webkit，Firefox)，也可以借助<strong>Node.js</strong>或者<strong>Rhino</strong>在服务端运行。</p><a id="more"></a><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="在客户端使用"><a href="#在客户端使用" class="headerlink" title="在客户端使用"></a>在客户端使用</h4><p>在引入<code>less.js</code>前先要把你的样式文件引入，引入你的 <code>.less</code> 样式文件的时候要设置 <code>rel</code> 属性值为 “<code>stylesheet/less</code>” :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles.less"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"less.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>备注：请在服务器环境下使用！本地直接打开可能会报错！</strong></p><h5 id="监视模式"><a href="#监视模式" class="headerlink" title="监视模式"></a>监视模式</h5><p>监视模式是客户端的一个功能，这个功能允许你当你改变样式的时候，客户端将自动刷新。</p><p>要使用它，只要在URL后面加上’<code>#!watch</code>‘，然后刷新页面就可以了。另外，你也可以通过在终端运行<code>less.watch()</code>来启动监视模式。</p><h4 id="在服务器端使用"><a href="#在服务器端使用" class="headerlink" title="在服务器端使用"></a>在服务器端使用</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>在服务器端安装less的最简单方式就是通过npm(node的包管理器)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less</span><br></pre></td></tr></table></figure><p>希望下载最新稳定版本的less，可以通过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less@latest</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'less'</span>)</span><br><span class="line"></span><br><span class="line">less.render(<span class="string">'.class &#123; width: 1 + 1 &#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e, css</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(css);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>你可以向解析器传递参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var parser = new(less.Parser)(&#123;</span><br><span class="line">    paths: [&apos;.&apos;, &apos;./lib&apos;], // Specify search paths for @import directives</span><br><span class="line">    filename: &apos;style.less&apos; // Specify a filename, for better error messages</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">parser.parse(&apos;.class &#123; width: 1 + 1 &#125;&apos;, function (e, tree) &#123;</span><br><span class="line">    tree.toCSS(&#123; compress: true &#125;); // Minify CSS output</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="在命令行下使用"><a href="#在命令行下使用" class="headerlink" title="在命令行下使用"></a>在命令行下使用</h5><p>你可以在终端调用 LESS 解析器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lessc styles.less</span><br></pre></td></tr></table></figure><p>上面的命令会将编译后的 CSS 传递给 <code>stdout</code>, 你可以将它保存到一个文件中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lessc styles.less &gt; styles.css</span><br></pre></td></tr></table></figure><p>如何你想将编译后的 CSS 压缩掉，那么加一个 <code>-x</code> 参数就可以了.</p><h3 id="less语法"><a href="#less语法" class="headerlink" title="less语法"></a>less语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@nice-blue:</span> <span class="number">#5B83AD</span>;</span><br><span class="line"><span class="variable">@light-blue:</span> <span class="variable">@nice-blue</span> + <span class="number">#111</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#header</span> &#123; <span class="attribute">color</span>: <span class="variable">@light-blue</span>; &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123; <span class="attribute">color</span>: <span class="number">#6c94be</span>; &#125;</span><br></pre></td></tr></table></figure><p>也可以用变量名定义为变量:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@name:</span> <span class="string">"I am name."</span>;</span><br><span class="line"><span class="variable">@var:</span> <span class="string">"Ankle"</span>;</span><br><span class="line"><span class="attribute">content</span>: <span class="variable">@@var</span>;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">content</span>: "<span class="selector-tag">I</span> <span class="selector-tag">am</span> <span class="selector-tag">Ankle</span>."</span><br></pre></td></tr></table></figure><p><strong>请注意 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次.</strong></p><h4 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h4><p>在less中可以定义一些通用的属性集为一个class，然后在另一个class中去调用这些属性，例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bordered</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: dotted <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">border-bottom</span>: solid <span class="number">2px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要在其他class中引入通用的属性集，调用如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#menu</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#111</span>;</span><br><span class="line">  <span class="selector-class">.bordered</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.bordered</code> class里面的属性样式会在 <code>#menu a</code> 中体现出来：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#menu</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#111</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: dotted <span class="number">1px</span> black;</span><br><span class="line">  <span class="attribute">border-bottom</span>: solid <span class="number">2px</span> black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任何 CSS <em>class</em>, <em>id</em> 或者 <em>元素</em> 属性集都可以以同样的方式引入.</strong></p><h4 id="带参数混合"><a href="#带参数混合" class="headerlink" title="带参数混合"></a>带参数混合</h4><p>在 LESS 中，你还可以像函数一样定义一个带参数的属性集合:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-radius</span> (<span class="variable">@radius</span>) &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="variable">@radius</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>: <span class="variable">@radius</span>;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>: <span class="variable">@radius</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*设置默认数值*/</span></span><br><span class="line"><span class="selector-class">.border-radius</span> (<span class="variable">@radius</span>: <span class="number">5px</span>) &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他class中调用：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="selector-class">.border-radius</span>(<span class="number">4px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#button</span> &#123;</span><br><span class="line">  <span class="selector-class">.border-radius</span>;   <span class="comment">// border-radius: 5px;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以定义不带参数属性集合,如果你想隐藏这个属性集合，不让它暴露到CSS中去，但是你还想在其他的属性集合中引用，你会发现这个方法非常的好用:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> () &#123;</span><br><span class="line">  <span class="attribute">text-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">  <span class="attribute">white-space</span>: -moz-pre-wrap;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">pre</span> &#123; <span class="selector-class">.wrap</span> &#125;</span><br></pre></td></tr></table></figure><p>解析：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pre</span> &#123;</span><br><span class="line">  <span class="attribute">text-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">  <span class="attribute">white-space</span>: -moz-pre-wrap;</span><br><span class="line">  <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@arguments</code> 变量</p><p><code>@arguments</code>包含了所有传递进来的参数. 如果你不想单独处理每一个参数的话：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-shadow</span> (<span class="variable">@x</span>: <span class="number">0</span>, <span class="variable">@y</span>: <span class="number">0</span>, <span class="variable">@blur</span>: <span class="number">1px</span>, <span class="variable">@color</span>: <span class="number">#000</span>) &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="variable">@arguments</span>;</span><br><span class="line">  <span class="attribute">-moz-box-shadow</span>: <span class="variable">@arguments</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-shadow</span>: <span class="variable">@arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-shadow</span>(<span class="number">2px</span>, <span class="number">5px</span>);</span><br></pre></td></tr></table></figure><p>解析：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: 2<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">-moz-box-shadow</span>: 2<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-shadow</span>: 2<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 1<span class="selector-tag">px</span> <span class="selector-id">#000</span>;</span><br></pre></td></tr></table></figure><h4 id="模式匹配和导引表达式"><a href="#模式匹配和导引表达式" class="headerlink" title="模式匹配和导引表达式"></a>模式匹配和导引表达式</h4><p><a href="http://www.bootcss.com/p/lesscss/#-parametric-mixins" target="_blank" rel="noopener">模式匹配和导引表达式</a></p><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><p>例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>: none &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>&amp;</code> 符号的使用—如果你想写串联选择器，而不是写后代选择器，就可以用到<code>&amp;</code>了. 这点对伪类尤其有用如 <code>:hover</code> 和 <code>:focus</code>.</p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>任何数字、颜色或者变量都可以参与运算. 来看一组例子:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base:</span> <span class="number">5%</span>;</span><br><span class="line"><span class="variable">@filler:</span> <span class="variable">@base</span> * <span class="number">2</span>;</span><br><span class="line"><span class="variable">@other:</span> <span class="variable">@base</span> + <span class="variable">@filter</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#888</span> / <span class="number">4</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@base-color</span> + <span class="number">#111</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span> / <span class="number">2</span> + <span class="variable">@filler</span>;</span><br></pre></td></tr></table></figure><p>LESS 的运算已经超出了我们的期望，它能够分辨出颜色和单位.</p><h4 id="Color函数"><a href="#Color函数" class="headerlink" title="Color函数"></a>Color函数</h4><p>LESS 提供了一系列的颜色运算函数. 颜色会先被转化成 HSL 色彩空间, 然后在通道级别操作:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lighten</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color which is 10% *lighter* than @color</span></span><br><span class="line"><span class="selector-tag">darken</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color which is 10% *darker* than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">saturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);    <span class="comment">// return a color 10% *more* saturated than @color</span></span><br><span class="line"><span class="selector-tag">desaturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);  <span class="comment">// return a color 10% *less* saturated than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">fadein</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color 10% *less* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fadeout</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color 10% *more* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fade</span>(<span class="variable">@color</span>, <span class="number">50%</span>);        <span class="comment">// return @color with 50% transparency</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, <span class="number">10</span>);         <span class="comment">// return a color with a 10 degree larger in hue than @color</span></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, -<span class="number">10</span>);        <span class="comment">// return a color with a 10 degree smaller hue than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mix</span>(<span class="variable">@color1</span>, <span class="variable">@color2</span>);    <span class="comment">// return a mix of @color1 and @color2</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base:</span> <span class="number">#f04615</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: saturate(<span class="variable">@base</span>, <span class="number">5%</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: lighten(spin(<span class="variable">@base</span>, <span class="number">8</span>), <span class="number">25%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Math函数"><a href="#Math函数" class="headerlink" title="Math函数"></a>Math函数</h4><p>LESS提供了一组方便的数学函数，你可以使用它们处理一些数字类型的值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">1.67</span>); <span class="comment">// returns `2`</span></span><br><span class="line">ceil(<span class="number">2.4</span>);   <span class="comment">// returns `3`</span></span><br><span class="line">floor(<span class="number">2.6</span>);  <span class="comment">// returns `2`</span></span><br></pre></td></tr></table></figure><p>如果你想将一个值转化为百分比，你可以使用<code>percentage</code> 函数:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">percentage</span>(<span class="number">0.5</span>); <span class="comment">// returns `50%`</span></span><br></pre></td></tr></table></figure><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>为了更好组织CSS或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 你可以像下面这样在<code>#bundle</code>中定义一些属性集之后可以重复使用:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#bundle</span> &#123;</span><br><span class="line">  <span class="selector-class">.button</span> () &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">background-color</span>: grey;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background-color</span>: white &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.tab</span> &#123; ... &#125;</span><br><span class="line">  <span class="selector-class">.citation</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#header</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: orange;</span><br><span class="line">  <span class="selector-id">#bundle</span> &gt; <span class="selector-class">.button</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> red;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#page</span> &#123;</span><br><span class="line">  <span class="variable">@var:</span> white;</span><br><span class="line">  <span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@var</span>; <span class="comment">// white</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@var</span>; <span class="comment">// red  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>CSS 形式的注释在 LESS 中是依然保留的:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Hello, I'm a CSS-style comment */</span></span><br><span class="line"><span class="selector-class">.class</span> &#123; <span class="attribute">color</span>: black &#125;</span><br></pre></td></tr></table></figure><p>LESS 同样也支持双斜线的注释, 但是编译成 CSS 的时候自动过滤掉:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hi, I'm a silent comment, I won't show up in your CSS</span></span><br><span class="line"><span class="selector-class">.class</span> &#123; <span class="attribute">color</span>: white &#125;</span><br></pre></td></tr></table></figure><h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>变量可以用下面的方式嵌入到字符串中，像<code>@{name}</code>这样的结构:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base-url:</span> <span class="string">"http://assets.fnord.com"</span>;</span><br><span class="line"><span class="attribute">background-image</span>: url(<span class="string">"@&#123;base-url&#125;/images/bg.png"</span>);</span><br></pre></td></tr></table></figure><h4 id="避免编译"><a href="#避免编译" class="headerlink" title="避免编译"></a>避免编译</h4><p>有时候我们需要输出一些不正确的CSS语法或者使用一些 LESS不认识的专有语法.</p><p>要输出这样的值我们可以在字符串前加上一个 <code>~</code>, 例如:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="string">~"ms:alwaysHasItsOwnSyntax.For.Stuff()"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将要避免编译的值用 “”包含起来，输出结果为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: ms:alwaysHasItsOwnSyntax.For.<span class="built_in">Stuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式?????"></a>JavaScript表达式?????</h4><p>JavaScript 表达式也可以在.less 文件中使用. 可以通过反引号的方式使用:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> <span class="built_in">`"hello".toUpperCase() + '!'`</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@var: &quot;HELLO!&quot;;</span><br></pre></td></tr></table></figure><p>注意你也可以同时使用字符串插值和避免编译:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@str:</span> <span class="string">"hello"</span>;</span><br><span class="line"><span class="variable">@var:</span> <span class="built_in">~`"@&#123;str&#125;".toUpperCase() + '!'`</span>;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> HELLO!;</span><br></pre></td></tr></table></figure><p>它也可以访问JavaScript环境:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@height:</span> <span class="built_in">`document.body.clientHeight`</span>;</span><br></pre></td></tr></table></figure><p>如果你想将一个JavaScript字符串解析成16进制的颜色值, 你可以使用 <code>color</code> 函数:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@color:</span> color(<span class="built_in">`window.colors.baseColor`</span>);</span><br><span class="line"><span class="variable">@darkcolor:</span> darken(<span class="variable">@color</span>, <span class="number">10%</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Less&quot;&gt;&lt;a href=&quot;#Less&quot; class=&quot;headerlink&quot; title=&quot;Less&quot;&gt;&lt;/a&gt;Less&lt;/h2&gt;&lt;p&gt;less是一种&lt;code&gt;动态&lt;/code&gt;样式&lt;code&gt;语言&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;less将css赋予了动态语言的特性，如&lt;strong&gt;变量&lt;/strong&gt;、&lt;strong&gt;继承&lt;/strong&gt;、&lt;strong&gt;运算&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt;。less既可以在&lt;strong&gt;客户端&lt;/strong&gt;运行（支持IE6+，Webkit，Firefox)，也可以借助&lt;strong&gt;Node.js&lt;/strong&gt;或者&lt;strong&gt;Rhino&lt;/strong&gt;在服务端运行。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>面试准备---ajax</title>
    <link href="http://gajya.github.io/2018/10/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E2%80%94%E2%80%94ajax/"/>
    <id>http://gajya.github.io/2018/10/23/面试准备——ajax/</id>
    <published>2018-10-23T11:00:16.000Z</published>
    <updated>2018-10-25T15:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是ajax"><a href="#什么是ajax" class="headerlink" title="什么是ajax"></a>什么是ajax</h2><p>AJAX(Asynchronous Javascript And XML) = 异步 JavaScript + XML 在后台与服务器进行<code>异步数据交换</code>，不用重载整个网页，实现局部刷新。</p><a id="more"></a><p>ajax的工作原理相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。交互模型为，ajax在浏览器端引入一个执行引擎，它一边接收user请求，一边传送数据给服务器，并把服务器端返回的结果展现给user。</p><p>简单说，通过 XMLHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用js来操作DOM而更新页面。关键是从服务器获取数据</p><p><strong>同步：</strong>脚本会停留并等待服务器发送回复然后继续</p><p><strong>异步：</strong>脚本不停留并处理可能的回复</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>不用重载整个网页，实现局部刷新</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不支持浏览器的back按钮</li><li>安全问题，ajax暴露了与服务器交互的细节</li><li>对搜索引擎的支持比较弱</li><li>不容易调试</li></ul><h2 id="创建ajax的步骤"><a href="#创建ajax的步骤" class="headerlink" title="创建ajax的步骤"></a>创建ajax的步骤</h2><ol><li>创建一个XMLHttpRequest对象</li><li>创建一个新的HTTP请求，并指定该HTTP请求类型、验证信息</li><li>设置请求头信息<code>setRequestHeader</code></li><li>设置响应 HTTP 请求状态变化的回调函数</li><li>发送 HTTP 请求</li><li>获取异步调用返回的数据</li><li>使用 JavaScript 和 DOM 实现局部刷新</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; (xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>)) &#123;</span><br><span class="line">        fn.call(<span class="keyword">this</span>, xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><h3 id="常见的http状态码以及代表的意义"><a href="#常见的http状态码以及代表的意义" class="headerlink" title="常见的http状态码以及代表的意义"></a>常见的http状态码以及代表的意义</h3><p>200（OK)：请求成功</p><p>301：永久重定向</p><p>303（See Other）：告知客户端使用另一个URL来获取资源</p><p>400（Bad Request)：请求格式错误</p><pre><code>1. 语义有误（客户端请求有语法错误），当前请求无法被服务器理解，除非修改，否则客户端不应该重复提交这个请求2. 请求参数有误</code></pre><p>404（Not Found)：请求失败，请求所希望得到的资源未被在服务器上发现</p><p>500（Internal Server Error)：服务器遇到一个未曾预料的状况，导致它无法完成对请求的处理</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是ajax&quot;&gt;&lt;a href=&quot;#什么是ajax&quot; class=&quot;headerlink&quot; title=&quot;什么是ajax&quot;&gt;&lt;/a&gt;什么是ajax&lt;/h2&gt;&lt;p&gt;AJAX(Asynchronous Javascript And XML) = 异步 JavaScript + XML 在后台与服务器进行&lt;code&gt;异步数据交换&lt;/code&gt;，不用重载整个网页，实现局部刷新。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="js" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/js/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://gajya.github.io/tags/js/"/>
    
      <category term="面试" scheme="http://gajya.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试准备——html</title>
    <link href="http://gajya.github.io/2018/10/21/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E2%80%94%E2%80%94html/"/>
    <id>http://gajya.github.io/2018/10/21/面试准备——html/</id>
    <published>2018-10-21T02:31:23.000Z</published>
    <updated>2018-10-25T15:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><strong>语义化</strong></p><ul><li>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构</li><li>css命名的语义化是指：为html标签添加有意义的class</li><li>为什么需要语义化：<ul><li>去掉样式后页面呈现清晰的结构</li><li>盲人使用读屏器更好地阅读</li><li>搜索引擎更好地理解页面，有利于收录</li><li>便团队项目的可持续运作及维护</li></ul></li></ul><a id="more"></a><p><strong>简述一下你对HTML语义化的理解？</strong></p><ul><li>用正确的标签做正确的事情。</li><li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li><li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li><li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li></ul><p><strong>Doctype作用？标准模式与兼容模式各有什么区别?</strong></p><ul><li><code>&lt;!DOCTYPE&gt;</code>声明位于位<code>于HTML</code>文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现</li><li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作</li></ul><p><strong>HTML5 为什么只需要写 ？</strong></p><ul><li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）</li><li>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</li></ul><p><strong>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</strong></p><ul><li>行内元素有：<code>a b span img input select strong</code>（强调的语气）</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></li><li>常见的空元素:<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li></ul><p><strong>页面导入样式时，使用link和@import有什么区别？</strong></p><ul><li><code>link</code>属于<code>XHTML</code>标签，除了加载<code>CSS</code>外，还能用于定义<code>RSS</code>,定义<code>rel</code>连接属性等作用；而<code>@import</code>是<code>CSS</code>提供的，只能用于加载<code>CSS</code></li><li>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载</li><li><code>import</code>是<code>CSS2.1</code> 提出的，只在<code>IE5</code>以上才能被识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题</li></ul><p><strong>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</strong></p><ul><li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加<ul><li>绘画 canvas</li><li>用于媒介回放的 video 和 audio 元素</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术webworker, websocket, Geolocation</li></ul></li><li>移除的元素：</li><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u</li><li>对可用性产生负面影响的元素：frame，frameset，noframes</li><li>支持HTML5新标签：<ul><li>IE8/IE7/IE6支持通过document.createElement方法产生的标签</li><li>可以利用这一特性让这些浏览器支持HTML5新标签</li><li>浏览器支持新标签后，还需要添加标签默认的样式</li></ul></li><li>当然也可以直接使用成熟的框架、比如html5shim</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script&gt; src=&quot;http://html5shim.googlecode.com</span><br><span class="line">/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><ul><li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li></ul><p><strong>HTML5的离线储存怎么使用，工作原理能不能解释一下？</strong></p><ul><li>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</li><li>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</li><li>如何使用：<ul><li>页面头部像下面一样加入一个manifest的属性；</li><li>在cache.manifest文件的编写离线存储的资源</li><li>在离线状态时，操作window.applicationCache进行需求实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure><p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</strong></p><ul><li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li><li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul><p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</strong></p><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li>存储大小：<ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li></ul></li><li>有期时间：<ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code> 数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code> 设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><p><strong>HTML5的form如何关闭自动完成功能？</strong></p><ul><li>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</li></ul><p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p><ul><li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li></ul><p><strong>如何在页面上实现一个圆形的可点击区域？</strong></p><ul><li>map+area或者svg</li><li>border-radius</li><li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li></ul><p><strong>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><p><strong>介绍一下你对浏览器内核的理解？</strong></p><ul><li>浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎</li><li>渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机</li><li>JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互</li><li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</li></ul><p><strong>常见的浏览器内核有哪些？</strong></p><ul><li>Blink内核：新版 Chrome、新版 Opera</li><li>Webkit内核：Safari、原Chrome</li><li>Gecko内核：FireFox、Netscape6及以上版本</li><li>Trident内核（又称MSHTML内核）：IE、国产浏览器</li><li>Presto内核：原Opera7及以上</li></ul><p><strong>HTML5有哪些新特性？</strong></p><ul><li>新增选择器 document.querySelector、document.querySelectorAll</li><li>拖拽释放(Drag and drop) API</li><li>媒体播放的 video 和 audio</li><li>本地存储 localStorage 和 sessionStorage</li><li>离线应用 manifest</li><li>桌面通知 Notifications</li><li>语意化标签 article、footer、header、nav、section</li><li>增强表单控件 calendar、date、time、email、url、search</li><li>地理位置 Geolocation</li><li>多任务 webworker</li><li>全双工通信协议 websocket</li><li>历史管理 history</li><li>跨域资源共享(CORS) Access-Control-Allow-Origin</li><li>页面可见性改变事件 visibilitychange</li><li>跨窗口通信 PostMessage</li><li>Form Data 对象</li><li>绘画 canvas</li></ul><p><strong>HTML5移除了那些元素？</strong></p><ul><li>纯表现的元素：basefont、big、center、font、s、strike、tt、u</li><li>对可用性产生负面影响的元素：frame、frameset、noframes</li></ul><p><strong>如何处理HTML5新标签的浏览器兼容问题？</strong></p><ul><li>通过 document.createElement 创建新标签</li><li>使用垫片 html5shiv.js</li></ul><p><strong>如何区分 HTML 和 HTML5？</strong></p><ul><li>DOCTYPE声明、新增的结构元素、功能元素</li></ul><p><strong>HTML5的离线储存工作原理能不能解释一下，怎么使用？</strong></p><ul><li>HTML5的离线储存原理：<ul><li>用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容</li></ul></li><li>HTML5的离线储存使用：<ul><li>在文档的 html 标签设置 manifest 属性，如 manifest=”/offline.appcache”</li><li>在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache</li><li>在 web 服务器配置正确的 MIME-type，即 text/cache-manifest</li></ul></li></ul><p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的？</strong></p><ul><li>在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件</li><li>如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储</li><li>如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li><li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul><p><strong>iframe 有那些优点和缺点？</strong></p><ul><li>优点：<ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本可以并行下载</li><li>可以实现跨子域通信</li></ul></li><li>缺点：<ul><li>iframe 会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎索识别</li><li>会产生很多页面，不容易管理</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li></ul></li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><p><strong>label 的作用是什么？怎么使用的？</strong></p><ul><li>label标签来定义表单控件的关系：<ul><li>当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上</li></ul></li><li>使用方法1：<ul><li><code>&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;</code></li><li><code>&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;</code></li></ul></li><li>使用方法2：<ul><li><code>&lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt;</code></li></ul></li></ul><p><strong>如何实现浏览器内多个标签页之间的通信？</strong></p><ul><li>iframe + contentWindow</li><li>postMessage</li><li>SharedWorker(Web Worker API)</li><li>storage 事件(localStorge API)</li><li>WebSocket</li></ul><p><strong>webSocket 如何兼容低浏览器？</strong></p><ul><li>Adobe Flash Socket</li><li>ActiveX HTMLFile (IE)</li><li>基于 multipart 编码发送 XHR</li><li>基于长轮询的 XHR</li></ul><p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p><ul><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li><li>当用户浏览其他页面，暂停网站首页幻灯自动播放</li><li>完成登陆后，无刷新自动同步其他页面的登录状态</li></ul><p><strong>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</strong></p><ul><li>title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><p>strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b是展示强调内容</p></li><li><p>i 内容展示为斜体，em 表示强调的文本</p></li><li>自然样式标签：b, i, u, s, pre</li><li>语义样式标签：strong, em, ins, del, code</li><li>应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;语义化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构&lt;/li&gt;
&lt;li&gt;css命名的语义化是指：为html标签添加有意义的class&lt;/li&gt;
&lt;li&gt;为什么需要语义化：&lt;ul&gt;
&lt;li&gt;去掉样式后页面呈现清晰的结构&lt;/li&gt;
&lt;li&gt;盲人使用读屏器更好地阅读&lt;/li&gt;
&lt;li&gt;搜索引擎更好地理解页面，有利于收录&lt;/li&gt;
&lt;li&gt;便团队项目的可持续运作及维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="h5" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/h5/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="h5" scheme="http://gajya.github.io/tags/h5/"/>
    
      <category term="面试" scheme="http://gajya.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6简单复习记录</title>
    <link href="http://gajya.github.io/2018/10/10/ES6%E7%AE%80%E5%8D%95%E5%A4%8D%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://gajya.github.io/2018/10/10/ES6简单复习记录/</id>
    <published>2018-10-10T10:43:32.000Z</published>
    <updated>2018-10-25T15:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><ul><li>箭头函数</li><li>数组的扩展运算符</li></ul><a id="more"></a><h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><ul><li>Object.keys、values、entries</li><li>对象方法简写，计算属性（主要掌握）</li><li>展开运算符（不是es6标准，但是babel也支持）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">'myjob'</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    num: <span class="number">1</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    name: <span class="string">'tiger'</span>,</span><br><span class="line">    job: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    work()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    key: <span class="string">'fe'</span>, <span class="comment">// 这样写打印出来，只是key: "fe"</span></span><br><span class="line">    [key]: <span class="string">'fe'</span>, <span class="comment">// </span></span><br><span class="line">    [key+<span class="string">'word'</span>]: <span class="string">'fe'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果</p><p><img src="/2018/10/10/ES6简单复习记录/Users/luoli/Library/Application%20Support/typora-user-images/image-20181010180702406.png" alt="image-20181010180702406"></p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li>数组解构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> [num1, num2] = arr</span><br><span class="line"><span class="built_in">console</span>.log(num1,num2)  <span class="comment">// num1 = 1  num2 = 2</span></span><br></pre></td></tr></table></figure><ul><li>对象解构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">type</span>: <span class="string">'IT'</span>,<span class="attr">name</span>: <span class="string">'tiger'</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;type, name&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(type,name)  <span class="comment">// type = IT  name = tiger</span></span><br></pre></td></tr></table></figure><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>告别seajs和require.js</p><ul><li>Import,import{}</li><li>Export, Export default</li><li>Node现在还不支持，需要用require来加载文件</li></ul><h3 id="Async-await-ES7"><a href="#Async-await-ES7" class="headerlink" title="Async await(ES7)"></a>Async await(ES7)</h3><p>更优雅的处理异步</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h3 id=&quot;函数的扩展&quot;&gt;&lt;a href=&quot;#函数的扩展&quot; class=&quot;headerlink&quot; title=&quot;函数的扩展&quot;&gt;&lt;/a&gt;函数的扩展&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;箭头函数&lt;/li&gt;
&lt;li&gt;数组的扩展运算符&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/es6/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="http://gajya.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>hexo的常用命令</title>
    <link href="http://gajya.github.io/2018/10/10/hexo%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://gajya.github.io/2018/10/10/hexo的常用命令/</id>
    <published>2018-10-10T10:32:25.000Z</published>
    <updated>2019-05-10T07:23:14.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><ul><li><code>hexo n &quot;我的博客&quot;</code> == <code>hexo new &quot;我的博客&quot;</code>    <strong>新建文章</strong></li><li><code>hexo p</code> == <code>hexo publish</code>   <strong>发布草稿 </strong></li><li><code>hexo g</code> == <code>hexo generate</code>   <strong>生成 </strong></li><li><code>hexo s</code> == <code>hexo server</code>   <strong>启动服务预览</strong></li><li><code>hexo d</code> == <code>hexo deploy</code>   <strong>部署</strong></li></ul><a id="more"></a><h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><blockquote><p>两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate</p></blockquote><p>简写： <code>hexo d -g</code> #完成后部署 <code>hexo s -g</code> #完成后启动本地服务，可通过默认端口预览访问</p><h2 id="只展示部分博客内容"><a href="#只展示部分博客内容" class="headerlink" title="只展示部分博客内容"></a>只展示部分博客内容</h2><p><code>&lt;!--more--&gt;</code></p><p> 以下是余下全文</p><h2 id="改变插入的图片大小"><a href="#改变插入的图片大小" class="headerlink" title="改变插入的图片大小"></a>改变插入的图片大小</h2><p>可以外面包裹div，单独设置<code>style</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: 200px; margin: auto&quot;&gt;![why](why.jpg)&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简写&quot;&gt;&lt;a href=&quot;#简写&quot; class=&quot;headerlink&quot; title=&quot;简写&quot;&gt;&lt;/a&gt;简写&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hexo n &amp;quot;我的博客&amp;quot;&lt;/code&gt; == &lt;code&gt;hexo new &amp;quot;我的博客&amp;quot;&lt;/code&gt;    &lt;strong&gt;新建文章&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexo p&lt;/code&gt; == &lt;code&gt;hexo publish&lt;/code&gt;   &lt;strong&gt;发布草稿 &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexo g&lt;/code&gt; == &lt;code&gt;hexo generate&lt;/code&gt;   &lt;strong&gt;生成 &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexo s&lt;/code&gt; == &lt;code&gt;hexo server&lt;/code&gt;   &lt;strong&gt;启动服务预览&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexo d&lt;/code&gt; == &lt;code&gt;hexo deploy&lt;/code&gt;   &lt;strong&gt;部署&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="其它" scheme="http://gajya.github.io/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="http://gajya.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>Vue响应式系统的基本原理</title>
    <link href="http://gajya.github.io/2018/09/25/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://gajya.github.io/2018/09/25/Vue响应式系统的基本原理/</id>
    <published>2018-09-25T05:44:02.000Z</published>
    <updated>2018-10-25T15:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h2><p>Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「<strong>响应式系统</strong>」。</p><a id="more"></a><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    obj: 目标对象</span></span><br><span class="line"><span class="comment">    prop: 需要操作的目标对象的属性名</span></span><br><span class="line"><span class="comment">    descriptor: 描述符</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    return value 传入对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)...</span><br></pre></td></tr></table></figure><p>descriptor的一些属性，简单介绍几个属性，具体可以参考 <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty" target="_blank" rel="noopener">MDN 文档</a>。</p><ul><li>enumerable，属性是否可枚举，默认false</li><li>configurable，属性是否可以被修改或者删除，默认false</li><li>get,获取属性的方法</li><li>set，设置属性的方法</li></ul><h2 id="实现observer（可观察的）"><a href="#实现observer（可观察的）" class="headerlink" title="实现observer（可观察的）"></a>实现observer（可观察的）</h2><p>在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程（流程图的init），它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」…</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606e8abbababbe6?imageslim" alt="img"></p><p>为了便于理解，我们不考虑数组等复杂的情况，只对对象进行处理。</p><ol><li>首先我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 渲染视图 */</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"视图更新啦～"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue的双向数据绑定"><a href="#vue的双向数据绑定" class="headerlink" title="vue的双向数据绑定"></a>vue的双向数据绑定</h3><ol start="2"><li>定义一个 defineReactive ，这个方法通过 Object.defineProperty 来实现对对象的「响应式」化，入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 defineReactive 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 reactiveGetter 方法，而在该属性被「写」的时候则会触发 reactiveSetter 方法。</li><li>当然这是不够的，我们需要在上面再封装一层 observer 。这个函数传入一个 value（需要「响应式」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 defineReactive 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>: <span class="string">'kindeng'</span>&#125;;</span><br><span class="line">observe(data);</span><br><span class="line">data.name = <span class="string">'dmq'</span>; <span class="comment">// 哈哈哈，监听到值变化了 kindeng --&gt; dmq</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    observe(val); <span class="comment">// 监听子属性</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">        configurable: <span class="literal">false</span>, <span class="comment">// 不能再define</span></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'哈哈哈，监听到值变化了 '</span>, val, <span class="string">' --&gt; '</span>, newVal);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出所有属性遍历</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol start="4"><li><p>用 <code>observer</code> 来封装一个 Vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四步</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Vue构造类 */</span></span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data = options.data;</span><br><span class="line">        observer(<span class="keyword">this</span>._data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们只要 new 一个 Vue 对象，就会将 <code>data</code> 中的数据进行「<strong>响应式</strong>」化。如果我们对 <code>data</code> 的属性进行下面的操作，就会触发 <code>cb</code> 方法更新视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: <span class="string">"I am test."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o._data.test = <span class="string">"hello,world."</span>;  <span class="comment">/*  哈哈哈，监听到值变化了,I am test. --&gt; hello,world. */</span></span><br></pre></td></tr></table></figure><p>Over</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;响应式系统&quot;&gt;&lt;a href=&quot;#响应式系统&quot; class=&quot;headerlink&quot; title=&quot;响应式系统&quot;&gt;&lt;/a&gt;响应式系统&lt;/h2&gt;&lt;p&gt;Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「&lt;strong&gt;响应式系统&lt;/strong&gt;」。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>为什么使用v-for要加上唯一的key</title>
    <link href="http://gajya.github.io/2018/09/20/v-for%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B7%BB%E5%8A%A0%E5%94%AF%E4%B8%80%E7%9A%84key/"/>
    <id>http://gajya.github.io/2018/09/20/v-for中为什么要添加唯一的key/</id>
    <published>2018-09-20T07:52:22.000Z</published>
    <updated>2018-10-25T15:10:38.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuelidate</title>
    <link href="http://gajya.github.io/2018/06/21/Vuelidate/"/>
    <id>http://gajya.github.io/2018/06/21/Vuelidate/</id>
    <published>2018-06-21T07:52:22.000Z</published>
    <updated>2019-12-02T07:08:54.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuelidate简介"><a href="#Vuelidate简介" class="headerlink" title="Vuelidate简介"></a>Vuelidate简介</h2><p>Vuelidate是一款简单轻量级的基于模块的Vue.js验证插件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装很简单，用npm来安装只需要一句话：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install vuelidate --save</span><br><span class="line">npm i -S vuelidate               <span class="comment">//简写</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在main.js中导入库并用作Vue插件，以便在包含验证配置的所有组件上全局启用该功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuelidate <span class="keyword">from</span> <span class="string">'vuelidate'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuelidate)<span class="comment">//安装插件</span></span><br></pre></td></tr></table></figure><h3 id="内置验证规则"><a href="#内置验证规则" class="headerlink" title="内置验证规则"></a>内置验证规则</h3><ul><li>required: 需要非空数据。检查仅包含空格的空数组和字符串。</li><li>maxLength:要求输入具有最大指定长度（包括最大值）。适用于数组。</li><li>minLength:要求输入具有最小指定长度（包括最小值）。适用于数组。</li><li>email: 接受有效的电子邮件地址。请记住，您仍然需要在服务器上进行仔细验证，因为无法发送验证电子邮件地址是否是真实的。</li><li>between: 检查数字或日期是否在指定范围内。最小值和最大值都包括在内。</li><li>ipAddress: 接受点分十进制表示形式的有效IPv4地址，如127.0.0.1。</li><li>alpha: 只接受字母字符。</li><li>alphaNum: 只接受字母数字。</li><li>numeric: 只接受数字。</li><li>sameAs: 检查给定属性是否相等。</li><li>url: 只接受网址。</li><li>or: 当至少有一个提供的验证器通过时通过。</li><li>and: 所有提供的验证器都通过时通过。</li><li>requiredIf: 仅当提供的属性或谓词为真时才需要非空数据。</li><li>requiredUnless: 仅当提供的属性或谓词为假时才需要非空数据。</li><li>minValue: 要求输入具有指定的最小数值或日期。</li><li>maxValue: 要求输入具有指定的最大数值或日期。</li></ul><h3 id="自定义验证规则（Custom-Validators）"><a href="#自定义验证规则（Custom-Validators）" class="headerlink" title="自定义验证规则（Custom Validators）"></a>自定义验证规则（Custom Validators）</h3><p>除了使用Vuelidate自带的内置验证规则外还可以使用自定义规则满足需求。</p><p>最简单的方法就是直接在当前文件的script里面设置校验规则，当然也可以单独的写一个my-validators.js的文件，无论是单独写还是抽离出来都需要引入.详情请参考  <a href="https://monterail.github.io/vuelidate/#custom-validators" target="_blank" rel="noopener">vuelidate的自定义验证规则</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; regex &#125; <span class="keyword">from</span> <span class="string">'vuelidate/lib/validators/common'</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">import</span> &#123; helpers &#125; <span class="keyword">from</span> <span class="string">'vuelidate/lib/validators'</span></span><br></pre></td></tr></table></figure><p>例子：</p><p>register.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 先引入需要用到的验证规则</span></span><br><span class="line"><span class="keyword">import</span> &#123; required, maxLength, sameAs &#125; <span class="keyword">from</span> <span class="string">'vuelidate/lib/validators'</span></span><br><span class="line"><span class="keyword">import</span> &#123; regex &#125; <span class="keyword">from</span> <span class="string">'vuelidate/lib/validators/common'</span></span><br><span class="line"><span class="keyword">var</span> phone = regex(<span class="string">'phoneNumber'</span>, /^<span class="number">1</span>(<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">7</span>|<span class="number">8</span>)\d&#123;<span class="number">9</span>&#125;$/) <span class="comment">// 手机号码校验</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            user: &#123;</span><br><span class="line">                username: <span class="string">''</span>,</span><br><span class="line">                password: <span class="string">''</span>,</span><br><span class="line">                confirmPassword: <span class="string">''</span>,</span><br><span class="line">                phone: <span class="string">''</span>,</span><br><span class="line">                phoneCode: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 2.定义验证字段的规则</span></span><br><span class="line">    validations: &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            username: &#123;</span><br><span class="line">                required,</span><br><span class="line">                <span class="comment">// minLength: minLength(2),</span></span><br><span class="line">                maxLength: maxLength(<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">async</span> isUnique (value) &#123; <span class="comment">// 异步校验用户名是否已注册</span></span><br><span class="line">                    <span class="keyword">if</span> (value === <span class="string">''</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`/api/unique/name/<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Boolean</span>(<span class="keyword">await</span> response.json())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            password: &#123;</span><br><span class="line">                required</span><br><span class="line">            &#125;,</span><br><span class="line">            confirmPassword: &#123;</span><br><span class="line">                sameAsPassword: sameAs(<span class="string">'password'</span>) <span class="comment">// 校验密码是否一致</span></span><br><span class="line">            &#125;,</span><br><span class="line">            phone: &#123;</span><br><span class="line">                required,</span><br><span class="line">                phone  <span class="comment">// 直接就是用的上面const设置的校验规则，自定义校验</span></span><br><span class="line">            &#125;,</span><br><span class="line">            phoneCode: &#123;</span><br><span class="line">                required</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register.vue的html部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; 'form-group--error': $v.user.password.$error &#125;"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"$v.user.password.$model"</span> </span></span><br><span class="line"><span class="tag">           @<span class="attr">blur</span>=<span class="string">"$v.user.password.$touch()"</span> <span class="attr">class</span>=<span class="string">"input-line"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">"password"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">placeholder</span>=<span class="string">"请设置密码"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"form-group__message"</span> <span class="attr">v-if</span>=<span class="string">"!$v.user.password.required"</span>&gt;</span>密码不能为空<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; 'form-group--error': $v.user.confirmPassword.$error &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"$v.user.confirmPassword.$model"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">class</span>=<span class="string">"input-line"</span> <span class="attr">type</span>=<span class="string">"password"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">placeholder</span>=<span class="string">"请确认密码"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"form-group__message"</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">v-if</span>=<span class="string">"!$v.user.confirmPassword.sameAsPassword"</span>&gt;</span>两次输入的密码不一致<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; 'form-group--error': $v.user.phone.$error &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"$v.user.phone.$model"</span> </span></span><br><span class="line"><span class="tag">           @<span class="attr">blur</span>=<span class="string">"$v.user.phone.$touch()"</span> <span class="attr">class</span>=<span class="string">"input-line"</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">placeholder</span>=<span class="string">"请输入手机号码"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"form-group__message"</span> <span class="attr">v-if</span>=<span class="string">"!$v.user.phone.required"</span>&gt;</span>手机号码不能为空<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"form-group__message"</span> <span class="attr">v-if</span>=<span class="string">"!$v.user.phone.phone"</span>&gt;</span>请输入正确的手机号码<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Register.vue的css部分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表单验证样式 */</span></span><br><span class="line"><span class="selector-class">.form-group__message</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#CC3333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.form-group--error</span> &gt; <span class="selector-tag">input</span> + <span class="selector-class">.form-group__message</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#CC3333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.form-group--error</span> <span class="selector-tag">input</span>, <span class="selector-class">.form-group--error</span> <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span>, <span class="selector-class">.form-group--error</span> <span class="selector-tag">input</span><span class="selector-pseudo">:hover</span>, <span class="selector-class">.form-group--error</span> <span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#CC3333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vuelidate简介&quot;&gt;&lt;a href=&quot;#Vuelidate简介&quot; class=&quot;headerlink&quot; title=&quot;Vuelidate简介&quot;&gt;&lt;/a&gt;Vuelidate简介&lt;/h2&gt;&lt;p&gt;Vuelidate是一款简单轻量级的基于模块的Vue.js验证插件。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装很简单，用npm来安装只需要一句话：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install vuelidate --save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm i -S vuelidate               &lt;span class=&quot;comment&quot;&gt;//简写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
      <category term="工具" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/tags/vue/"/>
    
      <category term="vue-工具" scheme="http://gajya.github.io/tags/vue-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli的使用方法</title>
    <link href="http://gajya.github.io/2017/10/19/vue-cli%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://gajya.github.io/2017/10/19/vue-cli的使用方法/</id>
    <published>2017-10-19T03:41:28.000Z</published>
    <updated>2018-10-25T15:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>vue-cli这个构建工具大大降低了webpack的使用难度，支持热更新，有webpack-dev-server的支持，相当于启动了一个请求服务器，给你搭建了一个测试环境，只关注开发就OK。</p><h2 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h2><ol><li>使用npm(需要安装node环境)全局安装webpack    <code>npm install webpack -g</code>，安装完毕后可以<code>webpack -v</code>检查webpack的版本号，有显示的话表示成功安装</li></ol><p><strong>注意：webpack4.x开始，需要安装webpack-cli依赖，命令<code>npm i webpack webpack-cli -g</code></strong></p><a id="more"></a><ol start="2"><li>全局安装vue-cli，命令<code>npm i vue-cli -g</code>，安装成功<code>vue -V</code>（<strong>v大写</strong>）检查版本号，判断是否安装成功。打开node_modules可以看到vue-cli文件夹</li></ol><h2 id="用vue-cli初始化项目"><a href="#用vue-cli初始化项目" class="headerlink" title="用vue-cli初始化项目"></a>用vue-cli初始化项目</h2><ol><li>新建文件夹<code>test</code>，打开命令行工具，cd进入该文件夹输入：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack TodoList</span><br></pre></td></tr></table></figure><p>TodoList是自定义的项目名称，命令执行后，会在test下生成一个该名称命名的项目文件夹</p><p><img src="/2017/10/19/vue-cli的使用方法/Users/luoli/Library/Application Support/typora-user-images/image-20181019120520437.png" alt="image-20181019120520437"></p><p>输入命令后，会跳出几个选项让你回答：</p><ul><li>Project name (baoge)： —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客<a href="https://link.jianshu.com/?t=http://www.ruanyifeng.com/blog/2017/02/filename-should-be-lowercase.html" target="_blank" rel="noopener">为什么文件名要小写</a> ，可以参考一下。</li><li>Project description (A Vue.js project)： —-项目描述，也可直接点击回车，使用默认名字</li><li>Author ()： —-作者，输入你的大名<br>接下来会让用户选择：</li><li>Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了<br>Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了</li><li>Install vue-router? (Y/n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。</li><li>Use ESLint to lint your code? (Y/n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。<br>接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，standard比较松散，所以可以直接y回车</li><li>Set up unit tests  (Y/n) 是否安装单元测试，我选择安装y回车</li><li>Setup e2e tests with Nightwatch(Y/n)? 是否安装e2e测试 ，我选择安装y回车</li></ul><p>回答完毕后上图就开始构建项目了。</p><ol start="2"><li><p>配置完成后，可以看到目录下多了一个项目文件夹TodoList，cd进入这个文件夹，安装依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure><p>( 如果安装速度太慢。可以安装淘宝镜像，打开命令行工具，输入：<br> <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br> 然后使用<code>cnpm</code>来安装 )</p><p>npm install ：</p><p>安装所有的模块，如果是安装具体的某个模块，在install 后面输入模块的名字即可。而只输入install就会按照项目的根目录下的package.json文件中依赖的模块安装（这个文件里面是不允许有任何注释的），每个使用npm管理的项目都有这个文件，是npm操作的入口文件。</p><p>因为是初始项目，还没有任何模块，所以用npm install 安装所有的模块。安装完成后，目录中会多出来一个node_modules文件夹，这里放的就是所有依赖的模块。</p><p>解释下每个文件夹代表的意思(仔细看一下这张图）：</p><p><img src="https://upload-images.jianshu.io/upload_images/10868449-01a038fa573b22c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/443" alt="img"></p></li></ol><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p>Cd进入TodoList文件夹，执行命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p>1.浏览器打开后，没有加载出页面</p><p>​    可能是本地8080端口占用，可以修改配置文件config里面的index.js</p><ol start="2"><li><p>本地调试时，打包遇到问题</p><p>建议将配置文件config里面的index.js的build 里的<code>assetsPublicPath</code>的路径前缀修改为 ‘ ./ ‘（开始是 ‘ / ‘），因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ / ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以如果需要在本地打开打包后的文件，就得修改文件路径</p></li><li><p>在进行vue页面调试时，建议去谷歌商店下载一个vue-tool扩展程序。</p></li></ol><h2 id="vue-cli的webpack配置分析"><a href="#vue-cli的webpack配置分析" class="headerlink" title="vue-cli的webpack配置分析"></a>vue-cli的webpack配置分析</h2><ul><li><p>从<code>package.json</code>可以看到开发和生产环境的入口。</p><p><img src="/2017/10/19/vue-cli的使用方法/Users/luoli/Library/Application Support/typora-user-images/image-20181019130507720.png" alt="image-20181019130507720"></p></li><li><p>可以看到dev中的设置，build/webpack.dev.conf.js，该文件是开发环境中webpack的配置入口。</p></li><li><p>在webpack.dev.conf.js中出现webpack.base.conf.js，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。</p></li><li><p>还有config/index.js 、build/utils.js 、build/build.js等，具体请看这篇介绍：<br><a href="https://link.jianshu.com/?t=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008644830" target="_blank" rel="noopener">vue-cli webpack配置分析</a></p></li></ul><h2 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h2><p>注意，自己的项目文件都需要放到 src 文件夹下。<br>在项目开发完成之后，可以输入 <code>npm run build</code> 来进行打包工作。</p><p>另：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>npm 开启了npm run dev以后怎么退出或关闭？</span><br><span class="line">ctrl+c</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>--save-dev</span><br><span class="line">自动把模块和版本号添加到模块配置文件package.json中的依赖里devdependencies部分</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> --save-dev 与 --save 的区别</span><br><span class="line">--save     安装包信息将加入到dependencies（生产阶段的依赖）</span><br><span class="line">--save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它</span><br></pre></td></tr></table></figure><p>打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。<br>项目上线时，只需要将 dist 文件夹放到服务器就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue-cli这个构建工具大大降低了webpack的使用难度，支持热更新，有webpack-dev-server的支持，相当于启动了一个请求服务器，给你搭建了一个测试环境，只关注开发就OK。&lt;/p&gt;
&lt;h2 id=&quot;安装vue-cli&quot;&gt;&lt;a href=&quot;#安装vue-cli&quot; class=&quot;headerlink&quot; title=&quot;安装vue-cli&quot;&gt;&lt;/a&gt;安装vue-cli&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用npm(需要安装node环境)全局安装webpack    &lt;code&gt;npm install webpack -g&lt;/code&gt;，安装完毕后可以&lt;code&gt;webpack -v&lt;/code&gt;检查webpack的版本号，有显示的话表示成功安装&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：webpack4.x开始，需要安装webpack-cli依赖，命令&lt;code&gt;npm i webpack webpack-cli -g&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="http://gajya.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="http://gajya.github.io/2017/09/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://gajya.github.io/2017/09/26/文件上传/</id>
    <published>2017-09-26T07:41:07.000Z</published>
    <updated>2018-10-25T15:10:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单的文件上传"><a href="#简单的文件上传" class="headerlink" title="简单的文件上传"></a>简单的文件上传</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"uploadForm"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"upload"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"myFile"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个最简单的文件上传。但是。。。ummmm，够胆你就提交这样的代码吧</p><a id="more"></a><h2 id="常用的上传方式——FormData"><a href="#常用的上传方式——FormData" class="headerlink" title="常用的上传方式——FormData"></a>常用的上传方式——FormData</h2><p>通过在脚本里新建FormData对象，把file对象设置到表单项中，然后利用XMLHttpRequest异步上传到服务器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line"><span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'myFil</span></span><br><span class="line"><span class="string">                                        e'</span>)</span><br><span class="line"><span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>]</span><br><span class="line">formData.append(<span class="string">'filename'</span>, file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(formData) <span class="comment">// 打印不出来东西</span></span><br><span class="line"><span class="comment">// 直接打印是看不到的，要用FormData的get()和getAll()方法</span></span><br><span class="line">formData.getAll(<span class="string">"filename"</span>)</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">'/upload.js'</span>)</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 对请求成功的处理</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请求成功"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.send(formData)</span><br><span class="line">xhr = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>以上，可以完成最基本的需求</p><p><a href="https://www.jianshu.com/p/46e6e03a0d53" target="_blank" rel="noopener">通过jQuery Ajax使用FormData对象上传文件</a></p><h2 id="上传进度"><a href="#上传进度" class="headerlink" title="上传进度"></a>上传进度</h2><p>XMLHttpRequest Level 2中，传送数据的时候，有一个progress事件，上传数据progress事件属于XMLHttpRequest.upload对象，上传数据过程中会触发，这个对象拥有下列方法：</p><p>这个对象拥有下列下列方法：</p><ul><li>onloadstart</li><li>onprogress</li><li>onabort</li><li>onerror</li><li>onload</li><li>ontimeout</li><li>onloadend</li></ul><p>这些方法在XHR对象中都存在同名版本，区别是后者是用于加载资源时，而前者用于资源上传时。其中onprogress 事件回调方法可用于跟踪资源上传的进度，它的event参数对象包含两个重要的属性loaded和total。分别代表当前已上传的字节数（number of bytes）和文件的总字节数。比如我们可以这样计算进度百分比：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.lengthComputable) &#123; <span class="comment">// lengthComputable ---- 文件总大小是否可知</span></span><br><span class="line">        <span class="keyword">var</span> percent = (e.loaded / e.total) * <span class="number">100</span></span><br><span class="line">        <span class="comment">// 对进度进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现代浏览器配合h5提供的<code>progress</code>享用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">"myProgress"</span> <span class="attr">value</span>=<span class="string">"50"</span> <span class="attr">max</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其value属性绑定上面代码中的<code>percent</code>的值即可。</p><p><strong>因为xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次。所以文件太小网络环境好的时候是直接到100%的。</strong></p><h2 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h2><p>普通青年的图片预览方式是待文件上传成功后，后台返回上传文件的url，然后把预览图片的img元素的src指向该url。这其实达不到预览的效果和目的。</p><p>属于文艺青年的现代浏览器又登场了：“使用HTML5的FileReader API吧！” 让我们直接上代码，直奔主题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleImageFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> previewArea = <span class="built_in">document</span>.getElementById(<span class="string">'previewArea'</span>);</span><br><span class="line">       <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">       <span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">"myFile"</span>);</span><br><span class="line">       <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">       img.file = file;</span><br><span class="line">       previewArea.appendChild(img);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">       reader.onload = (<span class="function"><span class="keyword">function</span>(<span class="params">aImg</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                 aImg.src = e.target.result;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;)(img);</span><br><span class="line">       reader.readAsDataURL(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用FileReader来处理图片的异步加载。在创建新的FileReader对象之后，我们建立了onload函数，然后调用readAsDataURL()开始在后台进行读取操作。当图像文件加载后，转换成一个 data: URL，并传递到onload回调函数中设置给img的src。</p><p>另外我们还可以通过使用对象URL来实现预览</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</span><br><span class="line">img.src = <span class="built_in">window</span>.URL.createObjectURL(file);;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 明确地通过调用释放</span></span><br><span class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(<span class="keyword">this</span>.src);</span><br><span class="line">&#125;</span><br><span class="line">previewArea.appendChild(img);</span><br></pre></td></tr></table></figure><h2 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"myFile"</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时代码里拿到的FileUpload对象的files属性就是一个选中的多文件的数组了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">"myFile"</span>);</span><br><span class="line"><span class="keyword">var</span> files = fileInput.files;</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = files[i];</span><br><span class="line">    formData.append(<span class="string">'files[]'</span>, file, file.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FormData的append方法提供第三个可选参数用于指定文件名，这样就可以使用同一个表单项名，然后用文件名区分上传的多个文件。这样也方便前后台的循环操作。</p><h2 id="拖拽选择文件"><a href="#拖拽选择文件" class="headerlink" title="拖拽选择文件"></a>拖拽选择文件</h2><p>利用HTML5的drag &amp; drop事件来实现对拖拽的支持。首先我们可能需要确定一个允许拖放的区域，然后绑定相应的事件进行处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dropArea</span><br><span class="line"></span><br><span class="line">dropArea = <span class="built_in">document</span>.getElementById(<span class="string">"dropArea"</span>)</span><br><span class="line">dropArea.addEventListener(<span class="string">"dragenter"</span>, handleDragenter, <span class="literal">false</span>)</span><br><span class="line">dropArea.addEventListener(<span class="string">"dragover"</span>, handleDragover, <span class="literal">false</span>)</span><br><span class="line">dropArea.addEventListener(<span class="string">"drop"</span>, handleDrop, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止dragenter和dragover的默认行为，这样才能使drop事件被触发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDragenter</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    e.preventDefault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDragover</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    e.preventDefault()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDrop</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">    e.preventDefault()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dt = e.dataTransfer</span><br><span class="line">    <span class="keyword">var</span> files = dt.files</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle files ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以把通过事件对象的dataTransfer拿到的files数组和之前相同处理，以实现预览上传等功能。有了这些事件回调，我们也可以在不同的事件给我们UI元素添加不同的class来实现更好交互效果。</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p>此外上传还有二进制上传，借用iframe实现上传，详情请参考<a href="https://juejin.im/entry/590ad4682f301e00582a78b5" target="_blank" rel="noopener">这篇文章</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="[www.qcloud.com](https://link.juejin.im/?target=https%3A%2F%2Fwww.qcloud.com%2Fcommunity%2Farticle%2F985614%3FfromSource%3Dgwzcw.114059.114059.114059">文件上传那些事儿</a></p><p><a href="https://www.jianshu.com/p/374e9b9d1fb1" target="_blank" rel="noopener">前端文件上传基础</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData" target="_blank" rel="noopener">FormData</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="noopener">html拖放API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单的文件上传&quot;&gt;&lt;a href=&quot;#简单的文件上传&quot; class=&quot;headerlink&quot; title=&quot;简单的文件上传&quot;&gt;&lt;/a&gt;简单的文件上传&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;uploadForm&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;POST&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;action&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;upload&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;enctype&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;multipart/form-data&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;file&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myFile&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;file&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;提交&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;input&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是一个最简单的文件上传。但是。。。ummmm，够胆你就提交这样的代码吧&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="h5" scheme="http://gajya.github.io/categories/%E5%89%8D%E7%AB%AF/javascript/h5/"/>
    
    
      <category term="前端" scheme="http://gajya.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://gajya.github.io/tags/javascript/"/>
    
      <category term="h5" scheme="http://gajya.github.io/tags/h5/"/>
    
  </entry>
  
</feed>
